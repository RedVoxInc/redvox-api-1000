// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: src/redvox-api-1000.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "src/RedvoxApi1000.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - RedvoxApi1000Root

@implementation RedvoxApi1000Root

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - RedvoxApi1000Root_FileDescriptor

static GPBFileDescriptor *RedvoxApi1000Root_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - RedvoxPacket1000

@implementation RedvoxPacket1000

@dynamic api;
@dynamic authEmail;
@dynamic authToken;
@dynamic firebaseToken;
@dynamic deviceId;
@dynamic deviceUuid;
@dynamic deviceMake;
@dynamic deviceModel;
@dynamic deviceOs;
@dynamic deviceOsVersion;
@dynamic deviceAppVersion;
@dynamic deviceTempC;
@dynamic deviceBatteryPercent;
@dynamic networkType;
@dynamic networkStrengthDb;
@dynamic isBackfilled;
@dynamic isPrivate;
@dynamic isMicScrambled;
@dynamic uncompressedSizeBytes;
@dynamic compressedSizeBytes;
@dynamic authServerURL;
@dynamic synchServerURL;
@dynamic acquisitionServerURL;
@dynamic packetStartTsUsWall;
@dynamic packetStartTsUsMach;
@dynamic packetEndTsUsWall;
@dynamic packetEndTsUsMach;
@dynamic serverAcquisitionArrivalTsUs;
@dynamic appStartTsUsMach;
@dynamic synchParamsArray, synchParamsArray_Count;
@dynamic bestLatencyUs;
@dynamic bestOffsetUs;
@dynamic hasMicrophoneChannel, microphoneChannel;
@dynamic hasBarometerChannel, barometerChannel;
@dynamic hasLocationChannel, locationChannel;
@dynamic hasAccelerometerChannel, accelerometerChannel;
@dynamic hasGyroscopeChannel, gyroscopeChannel;
@dynamic hasMagnetometerChannel, magnetometerChannel;
@dynamic hasLightChannel, lightChannel;
@dynamic hasInfraredChannel, infraredChannel;
@dynamic metadata, metadata_Count;

typedef struct RedvoxPacket1000__storage_ {
  uint32_t _has_storage_[2];
  uint32_t api;
  RedvoxPacket1000_OsType deviceOs;
  RedvoxPacket1000_NetworkType networkType;
  NSString *authEmail;
  NSString *authToken;
  NSString *firebaseToken;
  NSString *deviceId;
  NSString *deviceUuid;
  NSString *deviceMake;
  NSString *deviceModel;
  NSString *deviceOsVersion;
  NSString *deviceAppVersion;
  NSString *authServerURL;
  NSString *synchServerURL;
  NSString *acquisitionServerURL;
  GPBDoubleArray *synchParamsArray;
  MicrophoneChannel *microphoneChannel;
  SingleChannel *barometerChannel;
  LocationChannel *locationChannel;
  XyzChannel *accelerometerChannel;
  XyzChannel *gyroscopeChannel;
  XyzChannel *magnetometerChannel;
  SingleChannel *lightChannel;
  SingleChannel *infraredChannel;
  NSMutableDictionary *metadata;
  double deviceTempC;
  double deviceBatteryPercent;
  double networkStrengthDb;
  double uncompressedSizeBytes;
  double compressedSizeBytes;
  double packetStartTsUsWall;
  double packetStartTsUsMach;
  double packetEndTsUsWall;
  double packetEndTsUsMach;
  double serverAcquisitionArrivalTsUs;
  double appStartTsUsMach;
  double bestLatencyUs;
  double bestOffsetUs;
} RedvoxPacket1000__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "api",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_Api,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, api),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "authEmail",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_AuthEmail,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, authEmail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "authToken",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_AuthToken,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, authToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "firebaseToken",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_FirebaseToken,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, firebaseToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceId",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_DeviceId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, deviceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceUuid",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_DeviceUuid,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, deviceUuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceMake",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_DeviceMake,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, deviceMake),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceModel",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_DeviceModel,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, deviceModel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceOs",
        .dataTypeSpecific.enumDescFunc = RedvoxPacket1000_OsType_EnumDescriptor,
        .number = RedvoxPacket1000_FieldNumber_DeviceOs,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, deviceOs),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "deviceOsVersion",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_DeviceOsVersion,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, deviceOsVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceAppVersion",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_DeviceAppVersion,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, deviceAppVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "deviceTempC",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_DeviceTempC,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, deviceTempC),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "deviceBatteryPercent",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_DeviceBatteryPercent,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, deviceBatteryPercent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "networkType",
        .dataTypeSpecific.enumDescFunc = RedvoxPacket1000_NetworkType_EnumDescriptor,
        .number = RedvoxPacket1000_FieldNumber_NetworkType,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, networkType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "networkStrengthDb",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_NetworkStrengthDb,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, networkStrengthDb),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "isBackfilled",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_IsBackfilled,
        .hasIndex = 15,
        .offset = 16,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isPrivate",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_IsPrivate,
        .hasIndex = 17,
        .offset = 18,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isMicScrambled",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_IsMicScrambled,
        .hasIndex = 19,
        .offset = 20,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "uncompressedSizeBytes",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_UncompressedSizeBytes,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, uncompressedSizeBytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "compressedSizeBytes",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_CompressedSizeBytes,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, compressedSizeBytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "authServerURL",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_AuthServerURL,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, authServerURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "synchServerURL",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_SynchServerURL,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, synchServerURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "acquisitionServerURL",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_AcquisitionServerURL,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, acquisitionServerURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "packetStartTsUsWall",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_PacketStartTsUsWall,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, packetStartTsUsWall),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "packetStartTsUsMach",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_PacketStartTsUsMach,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, packetStartTsUsMach),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "packetEndTsUsWall",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_PacketEndTsUsWall,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, packetEndTsUsWall),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "packetEndTsUsMach",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_PacketEndTsUsMach,
        .hasIndex = 29,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, packetEndTsUsMach),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "serverAcquisitionArrivalTsUs",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_ServerAcquisitionArrivalTsUs,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, serverAcquisitionArrivalTsUs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "appStartTsUsMach",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_AppStartTsUsMach,
        .hasIndex = 31,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, appStartTsUsMach),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "synchParamsArray",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_SynchParamsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, synchParamsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "bestLatencyUs",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_BestLatencyUs,
        .hasIndex = 32,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, bestLatencyUs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "bestOffsetUs",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_BestOffsetUs,
        .hasIndex = 33,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, bestOffsetUs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "microphoneChannel",
        .dataTypeSpecific.className = GPBStringifySymbol(MicrophoneChannel),
        .number = RedvoxPacket1000_FieldNumber_MicrophoneChannel,
        .hasIndex = 34,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, microphoneChannel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "barometerChannel",
        .dataTypeSpecific.className = GPBStringifySymbol(SingleChannel),
        .number = RedvoxPacket1000_FieldNumber_BarometerChannel,
        .hasIndex = 35,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, barometerChannel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "locationChannel",
        .dataTypeSpecific.className = GPBStringifySymbol(LocationChannel),
        .number = RedvoxPacket1000_FieldNumber_LocationChannel,
        .hasIndex = 36,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, locationChannel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "accelerometerChannel",
        .dataTypeSpecific.className = GPBStringifySymbol(XyzChannel),
        .number = RedvoxPacket1000_FieldNumber_AccelerometerChannel,
        .hasIndex = 37,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, accelerometerChannel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gyroscopeChannel",
        .dataTypeSpecific.className = GPBStringifySymbol(XyzChannel),
        .number = RedvoxPacket1000_FieldNumber_GyroscopeChannel,
        .hasIndex = 38,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, gyroscopeChannel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "magnetometerChannel",
        .dataTypeSpecific.className = GPBStringifySymbol(XyzChannel),
        .number = RedvoxPacket1000_FieldNumber_MagnetometerChannel,
        .hasIndex = 39,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, magnetometerChannel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lightChannel",
        .dataTypeSpecific.className = GPBStringifySymbol(SingleChannel),
        .number = RedvoxPacket1000_FieldNumber_LightChannel,
        .hasIndex = 40,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, lightChannel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "infraredChannel",
        .dataTypeSpecific.className = GPBStringifySymbol(SingleChannel),
        .number = RedvoxPacket1000_FieldNumber_InfraredChannel,
        .hasIndex = 41,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, infraredChannel),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacket1000_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacket1000__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedvoxPacket1000 class]
                                     rootClass:[RedvoxApi1000Root class]
                                          file:RedvoxApi1000Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedvoxPacket1000__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\025\004\246\241!!\000\026\005\246\241!!\000\027\013\246\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RedvoxPacket1000_DeviceOs_RawValue(RedvoxPacket1000 *message) {
  GPBDescriptor *descriptor = [RedvoxPacket1000 descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacket1000_FieldNumber_DeviceOs];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacket1000_DeviceOs_RawValue(RedvoxPacket1000 *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacket1000 descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacket1000_FieldNumber_DeviceOs];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t RedvoxPacket1000_NetworkType_RawValue(RedvoxPacket1000 *message) {
  GPBDescriptor *descriptor = [RedvoxPacket1000 descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacket1000_FieldNumber_NetworkType];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacket1000_NetworkType_RawValue(RedvoxPacket1000 *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacket1000 descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacket1000_FieldNumber_NetworkType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RedvoxPacket1000_NetworkType

GPBEnumDescriptor *RedvoxPacket1000_NetworkType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Wifi\000Cellular\000None\000";
    static const int32_t values[] = {
        RedvoxPacket1000_NetworkType_Wifi,
        RedvoxPacket1000_NetworkType_Cellular,
        RedvoxPacket1000_NetworkType_None,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RedvoxPacket1000_NetworkType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RedvoxPacket1000_NetworkType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RedvoxPacket1000_NetworkType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RedvoxPacket1000_NetworkType_Wifi:
    case RedvoxPacket1000_NetworkType_Cellular:
    case RedvoxPacket1000_NetworkType_None:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum RedvoxPacket1000_OsType

GPBEnumDescriptor *RedvoxPacket1000_OsType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Android\000Ios\000Linux\000Windows\000";
    static const int32_t values[] = {
        RedvoxPacket1000_OsType_Android,
        RedvoxPacket1000_OsType_Ios,
        RedvoxPacket1000_OsType_Linux,
        RedvoxPacket1000_OsType_Windows,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RedvoxPacket1000_OsType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RedvoxPacket1000_OsType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RedvoxPacket1000_OsType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RedvoxPacket1000_OsType_Android:
    case RedvoxPacket1000_OsType_Ios:
    case RedvoxPacket1000_OsType_Linux:
    case RedvoxPacket1000_OsType_Windows:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - MicrophoneChannel

@implementation MicrophoneChannel

@dynamic sensorDescription;
@dynamic firstSampleTsUs;
@dynamic sampleRateHz;
@dynamic samplesArray, samplesArray_Count;
@dynamic hasSampleStatistics, sampleStatistics;
@dynamic metadata, metadata_Count;

typedef struct MicrophoneChannel__storage_ {
  uint32_t _has_storage_[1];
  NSString *sensorDescription;
  GPBDoubleArray *samplesArray;
  SummaryStatistics *sampleStatistics;
  NSMutableDictionary *metadata;
  double firstSampleTsUs;
  double sampleRateHz;
} MicrophoneChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sensorDescription",
        .dataTypeSpecific.className = NULL,
        .number = MicrophoneChannel_FieldNumber_SensorDescription,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(MicrophoneChannel__storage_, sensorDescription),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "firstSampleTsUs",
        .dataTypeSpecific.className = NULL,
        .number = MicrophoneChannel_FieldNumber_FirstSampleTsUs,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(MicrophoneChannel__storage_, firstSampleTsUs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "sampleRateHz",
        .dataTypeSpecific.className = NULL,
        .number = MicrophoneChannel_FieldNumber_SampleRateHz,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(MicrophoneChannel__storage_, sampleRateHz),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "samplesArray",
        .dataTypeSpecific.className = NULL,
        .number = MicrophoneChannel_FieldNumber_SamplesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MicrophoneChannel__storage_, samplesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "sampleStatistics",
        .dataTypeSpecific.className = GPBStringifySymbol(SummaryStatistics),
        .number = MicrophoneChannel_FieldNumber_SampleStatistics,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(MicrophoneChannel__storage_, sampleStatistics),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = MicrophoneChannel_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(MicrophoneChannel__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[MicrophoneChannel class]
                                     rootClass:[RedvoxApi1000Root class]
                                          file:RedvoxApi1000Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(MicrophoneChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SingleChannel

@implementation SingleChannel

@dynamic sensorDescription;
@dynamic meanSampleRateHz;
@dynamic sampleTsUsArray, sampleTsUsArray_Count;
@dynamic samplesArray, samplesArray_Count;
@dynamic hasSampleRateStatistics, sampleRateStatistics;
@dynamic hasSampleStatistics, sampleStatistics;
@dynamic metadata, metadata_Count;

typedef struct SingleChannel__storage_ {
  uint32_t _has_storage_[1];
  NSString *sensorDescription;
  GPBDoubleArray *sampleTsUsArray;
  GPBDoubleArray *samplesArray;
  SummaryStatistics *sampleRateStatistics;
  SummaryStatistics *sampleStatistics;
  NSMutableDictionary *metadata;
  double meanSampleRateHz;
} SingleChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sensorDescription",
        .dataTypeSpecific.className = NULL,
        .number = SingleChannel_FieldNumber_SensorDescription,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SingleChannel__storage_, sensorDescription),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "meanSampleRateHz",
        .dataTypeSpecific.className = NULL,
        .number = SingleChannel_FieldNumber_MeanSampleRateHz,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SingleChannel__storage_, meanSampleRateHz),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "sampleTsUsArray",
        .dataTypeSpecific.className = NULL,
        .number = SingleChannel_FieldNumber_SampleTsUsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SingleChannel__storage_, sampleTsUsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "samplesArray",
        .dataTypeSpecific.className = NULL,
        .number = SingleChannel_FieldNumber_SamplesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SingleChannel__storage_, samplesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "sampleRateStatistics",
        .dataTypeSpecific.className = GPBStringifySymbol(SummaryStatistics),
        .number = SingleChannel_FieldNumber_SampleRateStatistics,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SingleChannel__storage_, sampleRateStatistics),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sampleStatistics",
        .dataTypeSpecific.className = GPBStringifySymbol(SummaryStatistics),
        .number = SingleChannel_FieldNumber_SampleStatistics,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SingleChannel__storage_, sampleStatistics),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = SingleChannel_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SingleChannel__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SingleChannel class]
                                     rootClass:[RedvoxApi1000Root class]
                                          file:RedvoxApi1000Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SingleChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - XyzChannel

@implementation XyzChannel

@dynamic sensorDescription;
@dynamic meanSampleRateHz;
@dynamic sampleTsUsArray, sampleTsUsArray_Count;
@dynamic xSamplesArray, xSamplesArray_Count;
@dynamic ySamplesArray, ySamplesArray_Count;
@dynamic zSamplesArray, zSamplesArray_Count;
@dynamic hasSampleRateStatistics, sampleRateStatistics;
@dynamic hasXSampleStatistics, xSampleStatistics;
@dynamic hasYSampleStatistics, ySampleStatistics;
@dynamic hasZSampleStatistics, zSampleStatistics;
@dynamic metadata, metadata_Count;

typedef struct XyzChannel__storage_ {
  uint32_t _has_storage_[1];
  NSString *sensorDescription;
  GPBDoubleArray *sampleTsUsArray;
  GPBDoubleArray *xSamplesArray;
  GPBDoubleArray *ySamplesArray;
  GPBDoubleArray *zSamplesArray;
  SummaryStatistics *sampleRateStatistics;
  SummaryStatistics *xSampleStatistics;
  SummaryStatistics *ySampleStatistics;
  SummaryStatistics *zSampleStatistics;
  NSMutableDictionary *metadata;
  double meanSampleRateHz;
} XyzChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sensorDescription",
        .dataTypeSpecific.className = NULL,
        .number = XyzChannel_FieldNumber_SensorDescription,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(XyzChannel__storage_, sensorDescription),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "meanSampleRateHz",
        .dataTypeSpecific.className = NULL,
        .number = XyzChannel_FieldNumber_MeanSampleRateHz,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(XyzChannel__storage_, meanSampleRateHz),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "sampleTsUsArray",
        .dataTypeSpecific.className = NULL,
        .number = XyzChannel_FieldNumber_SampleTsUsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(XyzChannel__storage_, sampleTsUsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "xSamplesArray",
        .dataTypeSpecific.className = NULL,
        .number = XyzChannel_FieldNumber_XSamplesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(XyzChannel__storage_, xSamplesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "ySamplesArray",
        .dataTypeSpecific.className = NULL,
        .number = XyzChannel_FieldNumber_YSamplesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(XyzChannel__storage_, ySamplesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "zSamplesArray",
        .dataTypeSpecific.className = NULL,
        .number = XyzChannel_FieldNumber_ZSamplesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(XyzChannel__storage_, zSamplesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "sampleRateStatistics",
        .dataTypeSpecific.className = GPBStringifySymbol(SummaryStatistics),
        .number = XyzChannel_FieldNumber_SampleRateStatistics,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(XyzChannel__storage_, sampleRateStatistics),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "xSampleStatistics",
        .dataTypeSpecific.className = GPBStringifySymbol(SummaryStatistics),
        .number = XyzChannel_FieldNumber_XSampleStatistics,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(XyzChannel__storage_, xSampleStatistics),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ySampleStatistics",
        .dataTypeSpecific.className = GPBStringifySymbol(SummaryStatistics),
        .number = XyzChannel_FieldNumber_YSampleStatistics,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(XyzChannel__storage_, ySampleStatistics),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "zSampleStatistics",
        .dataTypeSpecific.className = GPBStringifySymbol(SummaryStatistics),
        .number = XyzChannel_FieldNumber_ZSampleStatistics,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(XyzChannel__storage_, zSampleStatistics),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = XyzChannel_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(XyzChannel__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[XyzChannel class]
                                     rootClass:[RedvoxApi1000Root class]
                                          file:RedvoxApi1000Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(XyzChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - LocationChannel

@implementation LocationChannel

@dynamic sensorDescription;
@dynamic meanSampleRateHz;
@dynamic sampleTsUsArray, sampleTsUsArray_Count;
@dynamic latitudeSamplesArray, latitudeSamplesArray_Count;
@dynamic longitudeSamplesArray, longitudeSamplesArray_Count;
@dynamic altitudeSamplesArray, altitudeSamplesArray_Count;
@dynamic speedSamplesArray, speedSamplesArray_Count;
@dynamic accuracySamplesArray, accuracySamplesArray_Count;
@dynamic locationPermissionsGranted;
@dynamic locationServicesRequested;
@dynamic locationServicesEnabled;
@dynamic locationProvider;
@dynamic hasSampleRateStatistics, sampleRateStatistics;
@dynamic hasLatitudeSampleStatistics, latitudeSampleStatistics;
@dynamic hasLongitudeSampleStatistics, longitudeSampleStatistics;
@dynamic hasAltitudeSampleStatistics, altitudeSampleStatistics;
@dynamic hasSpeedSampleStatistics, speedSampleStatistics;
@dynamic hasAccuracySampleStatistics, accuracySampleStatistics;
@dynamic metadata, metadata_Count;

typedef struct LocationChannel__storage_ {
  uint32_t _has_storage_[1];
  LocationChannel_LocationProvider locationProvider;
  NSString *sensorDescription;
  GPBDoubleArray *sampleTsUsArray;
  GPBDoubleArray *latitudeSamplesArray;
  GPBDoubleArray *longitudeSamplesArray;
  GPBDoubleArray *altitudeSamplesArray;
  GPBDoubleArray *speedSamplesArray;
  GPBDoubleArray *accuracySamplesArray;
  SummaryStatistics *sampleRateStatistics;
  SummaryStatistics *latitudeSampleStatistics;
  SummaryStatistics *longitudeSampleStatistics;
  SummaryStatistics *altitudeSampleStatistics;
  SummaryStatistics *speedSampleStatistics;
  SummaryStatistics *accuracySampleStatistics;
  NSMutableDictionary *metadata;
  double meanSampleRateHz;
} LocationChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sensorDescription",
        .dataTypeSpecific.className = NULL,
        .number = LocationChannel_FieldNumber_SensorDescription,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(LocationChannel__storage_, sensorDescription),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "meanSampleRateHz",
        .dataTypeSpecific.className = NULL,
        .number = LocationChannel_FieldNumber_MeanSampleRateHz,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(LocationChannel__storage_, meanSampleRateHz),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "sampleTsUsArray",
        .dataTypeSpecific.className = NULL,
        .number = LocationChannel_FieldNumber_SampleTsUsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LocationChannel__storage_, sampleTsUsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "latitudeSamplesArray",
        .dataTypeSpecific.className = NULL,
        .number = LocationChannel_FieldNumber_LatitudeSamplesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LocationChannel__storage_, latitudeSamplesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "longitudeSamplesArray",
        .dataTypeSpecific.className = NULL,
        .number = LocationChannel_FieldNumber_LongitudeSamplesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LocationChannel__storage_, longitudeSamplesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "altitudeSamplesArray",
        .dataTypeSpecific.className = NULL,
        .number = LocationChannel_FieldNumber_AltitudeSamplesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LocationChannel__storage_, altitudeSamplesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "speedSamplesArray",
        .dataTypeSpecific.className = NULL,
        .number = LocationChannel_FieldNumber_SpeedSamplesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LocationChannel__storage_, speedSamplesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "accuracySamplesArray",
        .dataTypeSpecific.className = NULL,
        .number = LocationChannel_FieldNumber_AccuracySamplesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LocationChannel__storage_, accuracySamplesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "locationPermissionsGranted",
        .dataTypeSpecific.className = NULL,
        .number = LocationChannel_FieldNumber_LocationPermissionsGranted,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "locationServicesRequested",
        .dataTypeSpecific.className = NULL,
        .number = LocationChannel_FieldNumber_LocationServicesRequested,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "locationServicesEnabled",
        .dataTypeSpecific.className = NULL,
        .number = LocationChannel_FieldNumber_LocationServicesEnabled,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "locationProvider",
        .dataTypeSpecific.enumDescFunc = LocationChannel_LocationProvider_EnumDescriptor,
        .number = LocationChannel_FieldNumber_LocationProvider,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(LocationChannel__storage_, locationProvider),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "sampleRateStatistics",
        .dataTypeSpecific.className = GPBStringifySymbol(SummaryStatistics),
        .number = LocationChannel_FieldNumber_SampleRateStatistics,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(LocationChannel__storage_, sampleRateStatistics),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "latitudeSampleStatistics",
        .dataTypeSpecific.className = GPBStringifySymbol(SummaryStatistics),
        .number = LocationChannel_FieldNumber_LatitudeSampleStatistics,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(LocationChannel__storage_, latitudeSampleStatistics),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "longitudeSampleStatistics",
        .dataTypeSpecific.className = GPBStringifySymbol(SummaryStatistics),
        .number = LocationChannel_FieldNumber_LongitudeSampleStatistics,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(LocationChannel__storage_, longitudeSampleStatistics),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "altitudeSampleStatistics",
        .dataTypeSpecific.className = GPBStringifySymbol(SummaryStatistics),
        .number = LocationChannel_FieldNumber_AltitudeSampleStatistics,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(LocationChannel__storage_, altitudeSampleStatistics),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "speedSampleStatistics",
        .dataTypeSpecific.className = GPBStringifySymbol(SummaryStatistics),
        .number = LocationChannel_FieldNumber_SpeedSampleStatistics,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(LocationChannel__storage_, speedSampleStatistics),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "accuracySampleStatistics",
        .dataTypeSpecific.className = GPBStringifySymbol(SummaryStatistics),
        .number = LocationChannel_FieldNumber_AccuracySampleStatistics,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(LocationChannel__storage_, accuracySampleStatistics),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = LocationChannel_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(LocationChannel__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[LocationChannel class]
                                     rootClass:[RedvoxApi1000Root class]
                                          file:RedvoxApi1000Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(LocationChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t LocationChannel_LocationProvider_RawValue(LocationChannel *message) {
  GPBDescriptor *descriptor = [LocationChannel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LocationChannel_FieldNumber_LocationProvider];
  return GPBGetMessageInt32Field(message, field);
}

void SetLocationChannel_LocationProvider_RawValue(LocationChannel *message, int32_t value) {
  GPBDescriptor *descriptor = [LocationChannel descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:LocationChannel_FieldNumber_LocationProvider];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum LocationChannel_LocationProvider

GPBEnumDescriptor *LocationChannel_LocationProvider_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "None\000User\000Gps\000Network\000";
    static const int32_t values[] = {
        LocationChannel_LocationProvider_None,
        LocationChannel_LocationProvider_User,
        LocationChannel_LocationProvider_Gps,
        LocationChannel_LocationProvider_Network,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(LocationChannel_LocationProvider)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:LocationChannel_LocationProvider_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL LocationChannel_LocationProvider_IsValidValue(int32_t value__) {
  switch (value__) {
    case LocationChannel_LocationProvider_None:
    case LocationChannel_LocationProvider_User:
    case LocationChannel_LocationProvider_Gps:
    case LocationChannel_LocationProvider_Network:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ImageChannel

@implementation ImageChannel

@dynamic sensorDescription;
@dynamic meanSampleRateHz;
@dynamic sampleTsUsArray, sampleTsUsArray_Count;
@dynamic samplesArray, samplesArray_Count;
@dynamic hasSampleRateStatistics, sampleRateStatistics;
@dynamic metadata, metadata_Count;

typedef struct ImageChannel__storage_ {
  uint32_t _has_storage_[1];
  NSString *sensorDescription;
  GPBDoubleArray *sampleTsUsArray;
  NSMutableArray *samplesArray;
  SummaryStatistics *sampleRateStatistics;
  NSMutableDictionary *metadata;
  double meanSampleRateHz;
} ImageChannel__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sensorDescription",
        .dataTypeSpecific.className = NULL,
        .number = ImageChannel_FieldNumber_SensorDescription,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ImageChannel__storage_, sensorDescription),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "meanSampleRateHz",
        .dataTypeSpecific.className = NULL,
        .number = ImageChannel_FieldNumber_MeanSampleRateHz,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ImageChannel__storage_, meanSampleRateHz),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "sampleTsUsArray",
        .dataTypeSpecific.className = NULL,
        .number = ImageChannel_FieldNumber_SampleTsUsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ImageChannel__storage_, sampleTsUsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "samplesArray",
        .dataTypeSpecific.className = NULL,
        .number = ImageChannel_FieldNumber_SamplesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ImageChannel__storage_, samplesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "sampleRateStatistics",
        .dataTypeSpecific.className = GPBStringifySymbol(SummaryStatistics),
        .number = ImageChannel_FieldNumber_SampleRateStatistics,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ImageChannel__storage_, sampleRateStatistics),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = ImageChannel_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ImageChannel__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ImageChannel class]
                                     rootClass:[RedvoxApi1000Root class]
                                          file:RedvoxApi1000Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ImageChannel__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SummaryStatistics

@implementation SummaryStatistics

@dynamic count;
@dynamic mean;
@dynamic median;
@dynamic mode;
@dynamic variance;
@dynamic min;
@dynamic max;
@dynamic range;
@dynamic metadata, metadata_Count;

typedef struct SummaryStatistics__storage_ {
  uint32_t _has_storage_[1];
  NSMutableDictionary *metadata;
  double count;
  double mean;
  double median;
  double mode;
  double variance;
  double min;
  double max;
  double range;
} SummaryStatistics__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = SummaryStatistics_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SummaryStatistics__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "mean",
        .dataTypeSpecific.className = NULL,
        .number = SummaryStatistics_FieldNumber_Mean,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SummaryStatistics__storage_, mean),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "median",
        .dataTypeSpecific.className = NULL,
        .number = SummaryStatistics_FieldNumber_Median,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SummaryStatistics__storage_, median),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "mode",
        .dataTypeSpecific.className = NULL,
        .number = SummaryStatistics_FieldNumber_Mode,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SummaryStatistics__storage_, mode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "variance",
        .dataTypeSpecific.className = NULL,
        .number = SummaryStatistics_FieldNumber_Variance,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SummaryStatistics__storage_, variance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "min",
        .dataTypeSpecific.className = NULL,
        .number = SummaryStatistics_FieldNumber_Min,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SummaryStatistics__storage_, min),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "max",
        .dataTypeSpecific.className = NULL,
        .number = SummaryStatistics_FieldNumber_Max,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(SummaryStatistics__storage_, max),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "range",
        .dataTypeSpecific.className = NULL,
        .number = SummaryStatistics_FieldNumber_Range,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(SummaryStatistics__storage_, range),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = SummaryStatistics_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(SummaryStatistics__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SummaryStatistics class]
                                     rootClass:[RedvoxApi1000Root class]
                                          file:RedvoxApi1000Root_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SummaryStatistics__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
