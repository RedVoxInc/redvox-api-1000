// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: src/redvox_api_m/redvox_api_m.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//*
// This file contains the protobuf message definitions for RedVox API 1000 (M) data and network communications.
//
// Standards and related documentation for API M is available at:
//   - https://github.com/RedVoxInc/redvox-api-1000

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Top level packet fields
struct RedvoxApiM_RedvoxPacketM {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The API version, should always be 1000
  var api: Float {
    get {return _storage._api}
    set {_uniqueStorage()._api = newValue}
  }

  /// The sub-api version.
  var subApi: Float {
    get {return _storage._subApi}
    set {_uniqueStorage()._subApi = newValue}
  }

  /// Station metadata/metrics
  var stationInformation: RedvoxApiM_RedvoxPacketM.StationInformation {
    get {return _storage._stationInformation ?? RedvoxApiM_RedvoxPacketM.StationInformation()}
    set {_uniqueStorage()._stationInformation = newValue}
  }
  /// Returns true if `stationInformation` has been explicitly set.
  var hasStationInformation: Bool {return _storage._stationInformation != nil}
  /// Clears the value of `stationInformation`. Subsequent reads from it will return its default value.
  mutating func clearStationInformation() {_uniqueStorage()._stationInformation = nil}

  /// Timing information, synch exchanges
  var timingInformation: RedvoxApiM_RedvoxPacketM.TimingInformation {
    get {return _storage._timingInformation ?? RedvoxApiM_RedvoxPacketM.TimingInformation()}
    set {_uniqueStorage()._timingInformation = newValue}
  }
  /// Returns true if `timingInformation` has been explicitly set.
  var hasTimingInformation: Bool {return _storage._timingInformation != nil}
  /// Clears the value of `timingInformation`. Subsequent reads from it will return its default value.
  mutating func clearTimingInformation() {_uniqueStorage()._timingInformation = nil}

  /// Sensors, payloads, etc
  var sensors: RedvoxApiM_RedvoxPacketM.Sensors {
    get {return _storage._sensors ?? RedvoxApiM_RedvoxPacketM.Sensors()}
    set {_uniqueStorage()._sensors = newValue}
  }
  /// Returns true if `sensors` has been explicitly set.
  var hasSensors: Bool {return _storage._sensors != nil}
  /// Clears the value of `sensors`. Subsequent reads from it will return its default value.
  mutating func clearSensors() {_uniqueStorage()._sensors = nil}

  /// Derived event streams
  var eventStreams: [RedvoxApiM_RedvoxPacketM.EventStream] {
    get {return _storage._eventStreams}
    set {_uniqueStorage()._eventStreams = newValue}
  }

  /// A map from string to string for including untyped metadata
  var metadata: Dictionary<String,String> {
    get {return _storage._metadata}
    set {_uniqueStorage()._metadata = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Enumeration of API M supported units
  enum Unit: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case metersPerSecondSquared // = 1
    case kilopascal // = 2
    case radiansPerSecond // = 3
    case decimalDegrees // = 4
    case meters // = 5
    case metersPerSecond // = 6
    case microtesla // = 7
    case lsbPlusMinusCounts // = 8
    case microsecondsSinceUnixEpoch // = 9
    case decibel // = 10
    case degreesCelsius // = 11
    case byte // = 12
    case percentage // = 13
    case radians // = 14
    case microamperes // = 15
    case centimeters // = 16
    case normalizedCounts // = 17
    case lux // = 18
    case less // = 19
    case pcm // = 20
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .metersPerSecondSquared
      case 2: self = .kilopascal
      case 3: self = .radiansPerSecond
      case 4: self = .decimalDegrees
      case 5: self = .meters
      case 6: self = .metersPerSecond
      case 7: self = .microtesla
      case 8: self = .lsbPlusMinusCounts
      case 9: self = .microsecondsSinceUnixEpoch
      case 10: self = .decibel
      case 11: self = .degreesCelsius
      case 12: self = .byte
      case 13: self = .percentage
      case 14: self = .radians
      case 15: self = .microamperes
      case 16: self = .centimeters
      case 17: self = .normalizedCounts
      case 18: self = .lux
      case 19: self = .less
      case 20: self = .pcm
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .metersPerSecondSquared: return 1
      case .kilopascal: return 2
      case .radiansPerSecond: return 3
      case .decimalDegrees: return 4
      case .meters: return 5
      case .metersPerSecond: return 6
      case .microtesla: return 7
      case .lsbPlusMinusCounts: return 8
      case .microsecondsSinceUnixEpoch: return 9
      case .decibel: return 10
      case .degreesCelsius: return 11
      case .byte: return 12
      case .percentage: return 13
      case .radians: return 14
      case .microamperes: return 15
      case .centimeters: return 16
      case .normalizedCounts: return 17
      case .lux: return 18
      case .less: return 19
      case .pcm: return 20
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// This message contains station metadata and related station state metrics
  struct StationInformation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The user selectable station id
    var id: String {
      get {return _storage._id}
      set {_uniqueStorage()._id = newValue}
    }

    /// The software provided UUID
    var uuid: String {
      get {return _storage._uuid}
      set {_uniqueStorage()._uuid = newValue}
    }

    /// Human friendly description of station (i.e. ISLA_0)
    var description_p: String {
      get {return _storage._description_p}
      set {_uniqueStorage()._description_p = newValue}
    }

    /// Authentication ID (user's email)
    var authID: String {
      get {return _storage._authID}
      set {_uniqueStorage()._authID = newValue}
    }

    /// Make of the station
    var make: String {
      get {return _storage._make}
      set {_uniqueStorage()._make = newValue}
    }

    /// Model of the station
    var model: String {
      get {return _storage._model}
      set {_uniqueStorage()._model = newValue}
    }

    /// OS of the station
    var os: RedvoxApiM_RedvoxPacketM.StationInformation.OsType {
      get {return _storage._os}
      set {_uniqueStorage()._os = newValue}
    }

    /// OS version of the station
    var osVersion: String {
      get {return _storage._osVersion}
      set {_uniqueStorage()._osVersion = newValue}
    }

    /// App version on the station
    var appVersion: String {
      get {return _storage._appVersion}
      set {_uniqueStorage()._appVersion = newValue}
    }

    /// If the station was set to record privately when this packet was recorded
    var isPrivate: Bool {
      get {return _storage._isPrivate}
      set {_uniqueStorage()._isPrivate = newValue}
    }

    /// A copy of the App's settings
    var appSettings: RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings {
      get {return _storage._appSettings ?? RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings()}
      set {_uniqueStorage()._appSettings = newValue}
    }
    /// Returns true if `appSettings` has been explicitly set.
    var hasAppSettings: Bool {return _storage._appSettings != nil}
    /// Clears the value of `appSettings`. Subsequent reads from it will return its default value.
    mutating func clearAppSettings() {_uniqueStorage()._appSettings = nil}

    /// Detail station performance metrics
    var stationMetrics: RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics {
      get {return _storage._stationMetrics ?? RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics()}
      set {_uniqueStorage()._stationMetrics = newValue}
    }
    /// Returns true if `stationMetrics` has been explicitly set.
    var hasStationMetrics: Bool {return _storage._stationMetrics != nil}
    /// Clears the value of `stationMetrics`. Subsequent reads from it will return its default value.
    mutating func clearStationMetrics() {_uniqueStorage()._stationMetrics = nil}

    /// URLs of remote services utilized by this station
    var serviceUrls: RedvoxApiM_RedvoxPacketM.StationInformation.ServiceUrls {
      get {return _storage._serviceUrls ?? RedvoxApiM_RedvoxPacketM.StationInformation.ServiceUrls()}
      set {_uniqueStorage()._serviceUrls = newValue}
    }
    /// Returns true if `serviceUrls` has been explicitly set.
    var hasServiceUrls: Bool {return _storage._serviceUrls != nil}
    /// Clears the value of `serviceUrls`. Subsequent reads from it will return its default value.
    mutating func clearServiceUrls() {_uniqueStorage()._serviceUrls = nil}

    /// A map from string to string for including untyped metadata
    var metadata: Dictionary<String,String> {
      get {return _storage._metadata}
      set {_uniqueStorage()._metadata = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// An enumeration specifying the available operating system types
    enum OsType: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case unknownOs // = 0
      case android // = 1
      case ios // = 2
      case osx // = 3
      case linux // = 4
      case windows // = 5
      case UNRECOGNIZED(Int)

      init() {
        self = .unknownOs
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknownOs
        case 1: self = .android
        case 2: self = .ios
        case 3: self = .osx
        case 4: self = .linux
        case 5: self = .windows
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknownOs: return 0
        case .android: return 1
        case .ios: return 2
        case .osx: return 3
        case .linux: return 4
        case .windows: return 5
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    /// Backend service URLs used in the creation of this packet
    struct ServiceUrls {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The URL of the authentication server
      var authServer: String = String()

      /// The URL of the synch server
      var synchServer: String = String()

      /// The URL of the acquisition server
      var acquisitionServer: String = String()

      /// A map from string to string for including untyped metadata
      var metadata: Dictionary<String,String> = [:]

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    /// Collection of station state and performance metrics
    struct StationMetrics {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Timestamps associated with following sensor state metrics
      var timestamps: RedvoxApiM_RedvoxPacketM.TimingPayload {
        get {return _storage._timestamps ?? RedvoxApiM_RedvoxPacketM.TimingPayload()}
        set {_uniqueStorage()._timestamps = newValue}
      }
      /// Returns true if `timestamps` has been explicitly set.
      var hasTimestamps: Bool {return _storage._timestamps != nil}
      /// Clears the value of `timestamps`. Subsequent reads from it will return its default value.
      mutating func clearTimestamps() {_uniqueStorage()._timestamps = nil}

      /// Type of network connection
      var networkType: [RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics.NetworkType] {
        get {return _storage._networkType}
        set {_uniqueStorage()._networkType = newValue}
      }

      /// State of the cellular service
      var cellServiceState: [RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics.CellServiceState] {
        get {return _storage._cellServiceState}
        set {_uniqueStorage()._cellServiceState = newValue}
      }

      /// A value representing the strength of the network connection in decibels
      var networkStrength: RedvoxApiM_RedvoxPacketM.SamplePayload {
        get {return _storage._networkStrength ?? RedvoxApiM_RedvoxPacketM.SamplePayload()}
        set {_uniqueStorage()._networkStrength = newValue}
      }
      /// Returns true if `networkStrength` has been explicitly set.
      var hasNetworkStrength: Bool {return _storage._networkStrength != nil}
      /// Clears the value of `networkStrength`. Subsequent reads from it will return its default value.
      mutating func clearNetworkStrength() {_uniqueStorage()._networkStrength = nil}

      /// Internal temperature of station in degrees Celsius
      var temperature: RedvoxApiM_RedvoxPacketM.SamplePayload {
        get {return _storage._temperature ?? RedvoxApiM_RedvoxPacketM.SamplePayload()}
        set {_uniqueStorage()._temperature = newValue}
      }
      /// Returns true if `temperature` has been explicitly set.
      var hasTemperature: Bool {return _storage._temperature != nil}
      /// Clears the value of `temperature`. Subsequent reads from it will return its default value.
      mutating func clearTemperature() {_uniqueStorage()._temperature = nil}

      /// Remaining percentage of station's battery
      var battery: RedvoxApiM_RedvoxPacketM.SamplePayload {
        get {return _storage._battery ?? RedvoxApiM_RedvoxPacketM.SamplePayload()}
        set {_uniqueStorage()._battery = newValue}
      }
      /// Returns true if `battery` has been explicitly set.
      var hasBattery: Bool {return _storage._battery != nil}
      /// Clears the value of `battery`. Subsequent reads from it will return its default value.
      mutating func clearBattery() {_uniqueStorage()._battery = nil}

      /// Current in microamperes
      var batteryCurrent: RedvoxApiM_RedvoxPacketM.SamplePayload {
        get {return _storage._batteryCurrent ?? RedvoxApiM_RedvoxPacketM.SamplePayload()}
        set {_uniqueStorage()._batteryCurrent = newValue}
      }
      /// Returns true if `batteryCurrent` has been explicitly set.
      var hasBatteryCurrent: Bool {return _storage._batteryCurrent != nil}
      /// Clears the value of `batteryCurrent`. Subsequent reads from it will return its default value.
      mutating func clearBatteryCurrent() {_uniqueStorage()._batteryCurrent = nil}

      /// Available ram in bytes
      var availableRam: RedvoxApiM_RedvoxPacketM.SamplePayload {
        get {return _storage._availableRam ?? RedvoxApiM_RedvoxPacketM.SamplePayload()}
        set {_uniqueStorage()._availableRam = newValue}
      }
      /// Returns true if `availableRam` has been explicitly set.
      var hasAvailableRam: Bool {return _storage._availableRam != nil}
      /// Clears the value of `availableRam`. Subsequent reads from it will return its default value.
      mutating func clearAvailableRam() {_uniqueStorage()._availableRam = nil}

      /// Available disk space in bytes
      var availableDisk: RedvoxApiM_RedvoxPacketM.SamplePayload {
        get {return _storage._availableDisk ?? RedvoxApiM_RedvoxPacketM.SamplePayload()}
        set {_uniqueStorage()._availableDisk = newValue}
      }
      /// Returns true if `availableDisk` has been explicitly set.
      var hasAvailableDisk: Bool {return _storage._availableDisk != nil}
      /// Clears the value of `availableDisk`. Subsequent reads from it will return its default value.
      mutating func clearAvailableDisk() {_uniqueStorage()._availableDisk = nil}

      /// CPU utilization as a percentage
      var cpuUtilization: RedvoxApiM_RedvoxPacketM.SamplePayload {
        get {return _storage._cpuUtilization ?? RedvoxApiM_RedvoxPacketM.SamplePayload()}
        set {_uniqueStorage()._cpuUtilization = newValue}
      }
      /// Returns true if `cpuUtilization` has been explicitly set.
      var hasCpuUtilization: Bool {return _storage._cpuUtilization != nil}
      /// Clears the value of `cpuUtilization`. Subsequent reads from it will return its default value.
      mutating func clearCpuUtilization() {_uniqueStorage()._cpuUtilization = nil}

      /// Power state enumeration
      var powerState: [RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics.PowerState] {
        get {return _storage._powerState}
        set {_uniqueStorage()._powerState = newValue}
      }

      /// If a wifi wake lock is being utilized
      var wifiWakeLock: [RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics.WifiWakeLock] {
        get {return _storage._wifiWakeLock}
        set {_uniqueStorage()._wifiWakeLock = newValue}
      }

      /// A map from string to string for including untyped metadata
      var metadata: Dictionary<String,String> {
        get {return _storage._metadata}
        set {_uniqueStorage()._metadata = newValue}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      /// An enumeration specifying the available network types
      enum NetworkType: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case unknownNetwork // = 0
        case noNetwork // = 1
        case wifi // = 2
        case cellular // = 3
        case wired // = 4
        case UNRECOGNIZED(Int)

        init() {
          self = .unknownNetwork
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknownNetwork
          case 1: self = .noNetwork
          case 2: self = .wifi
          case 3: self = .cellular
          case 4: self = .wired
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknownNetwork: return 0
          case .noNetwork: return 1
          case .wifi: return 2
          case .cellular: return 3
          case .wired: return 4
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      /// Type of WiFi wake lock un use
      enum WifiWakeLock: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case none // = 0
        case highPerf // = 1
        case lowLatency // = 2
        case other // = 3
        case UNRECOGNIZED(Int)

        init() {
          self = .none
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .none
          case 1: self = .highPerf
          case 2: self = .lowLatency
          case 3: self = .other
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .none: return 0
          case .highPerf: return 1
          case .lowLatency: return 2
          case .other: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      /// State of the cellular service
      enum CellServiceState: SwiftProtobuf.Enum {
        typealias RawValue = Int

        /// State is unknown
        case unknown // = 0

        /// Only emergency calls
        case emergency // = 1

        /// Everything is working fine
        case nominal // = 2

        /// Cell is searching for service, no available networks
        case outOfService // = 3

        /// Cellular radio is powered off
        case powerOff // = 4
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .emergency
          case 2: self = .nominal
          case 3: self = .outOfService
          case 4: self = .powerOff
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .emergency: return 1
          case .nominal: return 2
          case .outOfService: return 3
          case .powerOff: return 4
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      /// The state of power supply to station
      enum PowerState: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case unknownPowerState // = 0
        case unplugged // = 1
        case charging // = 2
        case charged // = 3
        case UNRECOGNIZED(Int)

        init() {
          self = .unknownPowerState
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknownPowerState
          case 1: self = .unplugged
          case 2: self = .charging
          case 3: self = .charged
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknownPowerState: return 0
          case .unplugged: return 1
          case .charging: return 2
          case .charged: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    /// A message that encapsulates the state of the app settings
    struct AppSettings {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The selected audio sampling rate
      var audioSamplingRate: RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings.AudioSamplingRate {
        get {return _storage._audioSamplingRate}
        set {_uniqueStorage()._audioSamplingRate = newValue}
      }

      var samplesPerWindow: Float {
        get {return _storage._samplesPerWindow}
        set {_uniqueStorage()._samplesPerWindow = newValue}
      }

      /// The selected audio source tuning
      var audioSourceTuning: RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings.AudioSourceTuning {
        get {return _storage._audioSourceTuning}
        set {_uniqueStorage()._audioSourceTuning = newValue}
      }

      /// Additional input sensors
      var additionalInputSensors: [RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings.InputSensor] {
        get {return _storage._additionalInputSensors}
        set {_uniqueStorage()._additionalInputSensors = newValue}
      }

      /// Station automatically records on start
      var automaticallyRecord: Bool {
        get {return _storage._automaticallyRecord}
        set {_uniqueStorage()._automaticallyRecord = newValue}
      }

      /// App automatically starts on station
      var launchAtPowerUp: Bool {
        get {return _storage._launchAtPowerUp}
        set {_uniqueStorage()._launchAtPowerUp = newValue}
      }

      /// User selectable station id
      var stationID: String {
        get {return _storage._stationID}
        set {_uniqueStorage()._stationID = newValue}
      }

      /// User selectable station description
      var stationDescription: String {
        get {return _storage._stationDescription}
        set {_uniqueStorage()._stationDescription = newValue}
      }

      /// Is station data pushed to server?
      var pushToServer: Bool {
        get {return _storage._pushToServer}
        set {_uniqueStorage()._pushToServer = newValue}
      }

      /// Is station data published as private?
      var publishDataAsPrivate: Bool {
        get {return _storage._publishDataAsPrivate}
        set {_uniqueStorage()._publishDataAsPrivate = newValue}
      }

      /// Is station audio data scrambled?
      var scrambleAudioData: Bool {
        get {return _storage._scrambleAudioData}
        set {_uniqueStorage()._scrambleAudioData = newValue}
      }

      /// Should station backfill unsent data?
      var provideBackfill: Bool {
        get {return _storage._provideBackfill}
        set {_uniqueStorage()._provideBackfill = newValue}
      }

      /// Does station remove DC offset?
      var removeSensorDcOffset: Bool {
        get {return _storage._removeSensorDcOffset}
        set {_uniqueStorage()._removeSensorDcOffset = newValue}
      }

      /// Station FFT overlap
      var fftOverlap: RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings.FftOverlap {
        get {return _storage._fftOverlap}
        set {_uniqueStorage()._fftOverlap = newValue}
      }

      /// Should station use custom time synch server?
      var useCustomTimeSyncServer: Bool {
        get {return _storage._useCustomTimeSyncServer}
        set {_uniqueStorage()._useCustomTimeSyncServer = newValue}
      }

      /// URL of custom time synch server
      var timeSyncServerURL: String {
        get {return _storage._timeSyncServerURL}
        set {_uniqueStorage()._timeSyncServerURL = newValue}
      }

      /// Should station use custom data server?
      var useCustomDataServer: Bool {
        get {return _storage._useCustomDataServer}
        set {_uniqueStorage()._useCustomDataServer = newValue}
      }

      /// URL of custom data server
      var dataServerURL: String {
        get {return _storage._dataServerURL}
        set {_uniqueStorage()._dataServerURL = newValue}
      }

      /// Should station use custom auth server
      var useCustomAuthServer: Bool {
        get {return _storage._useCustomAuthServer}
        set {_uniqueStorage()._useCustomAuthServer = newValue}
      }

      /// URL of custom auth server
      var authServerURL: String {
        get {return _storage._authServerURL}
        set {_uniqueStorage()._authServerURL = newValue}
      }

      /// Should station auto delete data?
      var autoDeleteDataFiles: Bool {
        get {return _storage._autoDeleteDataFiles}
        set {_uniqueStorage()._autoDeleteDataFiles = newValue}
      }

      /// Station data allowance in bytes
      var storageSpaceAllowance: Float {
        get {return _storage._storageSpaceAllowance}
        set {_uniqueStorage()._storageSpaceAllowance = newValue}
      }

      /// Should station use SD card for storage?
      var useSdCardForDataStorage: Bool {
        get {return _storage._useSdCardForDataStorage}
        set {_uniqueStorage()._useSdCardForDataStorage = newValue}
      }

      /// Should station use location services?
      var useLocationServices: Bool {
        get {return _storage._useLocationServices}
        set {_uniqueStorage()._useLocationServices = newValue}
      }

      /// User set latitude decimal degrees
      var useLatitude: Double {
        get {return _storage._useLatitude}
        set {_uniqueStorage()._useLatitude = newValue}
      }

      /// User set longitude decimal degrees
      var useLongitude: Double {
        get {return _storage._useLongitude}
        set {_uniqueStorage()._useLongitude = newValue}
      }

      /// User set altitude meters
      var useAltitude: Float {
        get {return _storage._useAltitude}
        set {_uniqueStorage()._useAltitude = newValue}
      }

      /// A map from string to string for including untyped metadata
      var metadata: Dictionary<String,String> {
        get {return _storage._metadata}
        set {_uniqueStorage()._metadata = newValue}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Configured FFT overlap
      enum FftOverlap: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case unknown // = 0
        case percent25 // = 1
        case percent50 // = 2
        case percent75 // = 3
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .percent25
          case 2: self = .percent50
          case 3: self = .percent75
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .percent25: return 1
          case .percent50: return 2
          case .percent75: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      /// Configured sampling rate
      enum AudioSamplingRate: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case unknownSamplingRate // = 0
        case hz80 // = 1
        case hz800 // = 2
        case hz8000 // = 3
        case hz16000 // = 4
        case hz48000 // = 5
        case UNRECOGNIZED(Int)

        init() {
          self = .unknownSamplingRate
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknownSamplingRate
          case 1: self = .hz80
          case 2: self = .hz800
          case 3: self = .hz8000
          case 4: self = .hz16000
          case 5: self = .hz48000
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknownSamplingRate: return 0
          case .hz80: return 1
          case .hz800: return 2
          case .hz8000: return 3
          case .hz16000: return 4
          case .hz48000: return 5
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      /// Configured audio source tuning
      enum AudioSourceTuning: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case unknownTuning // = 0
        case infrasoundTuning // = 1
        case lowAudioTuning // = 2
        case audioTuning // = 3
        case UNRECOGNIZED(Int)

        init() {
          self = .unknownTuning
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknownTuning
          case 1: self = .infrasoundTuning
          case 2: self = .lowAudioTuning
          case 3: self = .audioTuning
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknownTuning: return 0
          case .infrasoundTuning: return 1
          case .lowAudioTuning: return 2
          case .audioTuning: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      /// Configured input sensors
      enum InputSensor: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case unknownSensor // = 0
        case accelerometer // = 1
        case ambientTemperature // = 2
        case audio // = 3
        case compressedAudio // = 4
        case gravity // = 5
        case gyroscope // = 6
        case image // = 7
        case light // = 8
        case linearAcceleration // = 9
        case location // = 10
        case magnetometer // = 11
        case orientation // = 12
        case pressure // = 13
        case proximity // = 14
        case relativeHumidity // = 15
        case rotationVector // = 16
        case UNRECOGNIZED(Int)

        init() {
          self = .unknownSensor
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknownSensor
          case 1: self = .accelerometer
          case 2: self = .ambientTemperature
          case 3: self = .audio
          case 4: self = .compressedAudio
          case 5: self = .gravity
          case 6: self = .gyroscope
          case 7: self = .image
          case 8: self = .light
          case 9: self = .linearAcceleration
          case 10: self = .location
          case 11: self = .magnetometer
          case 12: self = .orientation
          case 13: self = .pressure
          case 14: self = .proximity
          case 15: self = .relativeHumidity
          case 16: self = .rotationVector
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknownSensor: return 0
          case .accelerometer: return 1
          case .ambientTemperature: return 2
          case .audio: return 3
          case .compressedAudio: return 4
          case .gravity: return 5
          case .gyroscope: return 6
          case .image: return 7
          case .light: return 8
          case .linearAcceleration: return 9
          case .location: return 10
          case .magnetometer: return 11
          case .orientation: return 12
          case .pressure: return 13
          case .proximity: return 14
          case .relativeHumidity: return 15
          case .rotationVector: return 16
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Stores timing information and related metrics
  /// See: https://github.com/RedVoxInc/redvox-api-1000/src/master/docs/standards/keeping_time.md
  struct TimingInformation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Start timestamp of the packet using the os clock (corresponding to first audio sample)
    var packetStartOsTimestamp: Double = 0

    /// Start timestamp of the packet using machine time (corresponding to the first audio sample)
    var packetStartMachTimestamp: Double = 0

    /// End timestamp of the packet using the os clock (corresponding to the last audio sample)
    var packetEndOsTimestamp: Double = 0

    /// End timestamp of the packet using machine time (corresponding to the last audio sample)
    var packetEndMachTimestamp: Double = 0

    /// Timestamp that the packet arrived at the acquisition server
    var serverAcquisitionArrivalTimestamp: Double = 0

    /// The start of the app as machine time
    var appStartMachTimestamp: Double = 0

    /// An array of synchronization params from the synch server
    var synchExchanges: [RedvoxApiM_RedvoxPacketM.TimingInformation.SynchExchange] = []

    /// The best latency as determined from the synch params in microseconds
    var bestLatency: Float = 0

    /// The best offset as determined from the synch params in microseconds
    var bestOffset: Float = 0

    /// The overall timing score
    var score: Float = 0

    /// Method used to provide score
    var scoreMethod: RedvoxApiM_RedvoxPacketM.TimingInformation.TimingScoreMethod = .unknown

    /// A unit describing the time (should always be MICROSECONDS_SINCE_UNIX_EPOCH)
    var unit: RedvoxApiM_RedvoxPacketM.Unit = .unknown

    /// A map from string to string for including untyped metadata
    var metadata: Dictionary<String,String> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Method used to score timing metrics
    enum TimingScoreMethod: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case unknown // = 0
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    /// Type-safe synchronization exchange values
    struct SynchExchange {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var a1: Double = 0

      var a2: Double = 0

      var a3: Double = 0

      var b1: Double = 0

      var b2: Double = 0

      var b3: Double = 0

      /// Unit of parameters a1-b3
      var unit: RedvoxApiM_RedvoxPacketM.Unit = .unknown

      /// A map from string to string for including untyped metadata
      var metadata: Dictionary<String,String> = [:]

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  /// Collection of available sensor types
  /// See: https://github.com/RedVoxInc/redvox-api-1000/src/master/docs/standards/standard_sensor_units.md
  struct Sensors {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// meters/second^2
    var accelerometer: RedvoxApiM_RedvoxPacketM.Sensors.Xyz {
      get {return _storage._accelerometer ?? RedvoxApiM_RedvoxPacketM.Sensors.Xyz()}
      set {_uniqueStorage()._accelerometer = newValue}
    }
    /// Returns true if `accelerometer` has been explicitly set.
    var hasAccelerometer: Bool {return _storage._accelerometer != nil}
    /// Clears the value of `accelerometer`. Subsequent reads from it will return its default value.
    mutating func clearAccelerometer() {_uniqueStorage()._accelerometer = nil}

    /// degrees Celsius
    var ambientTemperature: RedvoxApiM_RedvoxPacketM.Sensors.Single {
      get {return _storage._ambientTemperature ?? RedvoxApiM_RedvoxPacketM.Sensors.Single()}
      set {_uniqueStorage()._ambientTemperature = newValue}
    }
    /// Returns true if `ambientTemperature` has been explicitly set.
    var hasAmbientTemperature: Bool {return _storage._ambientTemperature != nil}
    /// Clears the value of `ambientTemperature`. Subsequent reads from it will return its default value.
    mutating func clearAmbientTemperature() {_uniqueStorage()._ambientTemperature = nil}

    /// normalized counts
    var audio: RedvoxApiM_RedvoxPacketM.Sensors.Audio {
      get {return _storage._audio ?? RedvoxApiM_RedvoxPacketM.Sensors.Audio()}
      set {_uniqueStorage()._audio = newValue}
    }
    /// Returns true if `audio` has been explicitly set.
    var hasAudio: Bool {return _storage._audio != nil}
    /// Clears the value of `audio`. Subsequent reads from it will return its default value.
    mutating func clearAudio() {_uniqueStorage()._audio = nil}

    /// bytes (codec specific)
    var compressedAudio: RedvoxApiM_RedvoxPacketM.Sensors.CompressedAudio {
      get {return _storage._compressedAudio ?? RedvoxApiM_RedvoxPacketM.Sensors.CompressedAudio()}
      set {_uniqueStorage()._compressedAudio = newValue}
    }
    /// Returns true if `compressedAudio` has been explicitly set.
    var hasCompressedAudio: Bool {return _storage._compressedAudio != nil}
    /// Clears the value of `compressedAudio`. Subsequent reads from it will return its default value.
    mutating func clearCompressedAudio() {_uniqueStorage()._compressedAudio = nil}

    /// meters/second^2
    var gravity: RedvoxApiM_RedvoxPacketM.Sensors.Xyz {
      get {return _storage._gravity ?? RedvoxApiM_RedvoxPacketM.Sensors.Xyz()}
      set {_uniqueStorage()._gravity = newValue}
    }
    /// Returns true if `gravity` has been explicitly set.
    var hasGravity: Bool {return _storage._gravity != nil}
    /// Clears the value of `gravity`. Subsequent reads from it will return its default value.
    mutating func clearGravity() {_uniqueStorage()._gravity = nil}

    /// radians/second
    var gyroscope: RedvoxApiM_RedvoxPacketM.Sensors.Xyz {
      get {return _storage._gyroscope ?? RedvoxApiM_RedvoxPacketM.Sensors.Xyz()}
      set {_uniqueStorage()._gyroscope = newValue}
    }
    /// Returns true if `gyroscope` has been explicitly set.
    var hasGyroscope: Bool {return _storage._gyroscope != nil}
    /// Clears the value of `gyroscope`. Subsequent reads from it will return its default value.
    mutating func clearGyroscope() {_uniqueStorage()._gyroscope = nil}

    /// bytes (codec specific)
    var image: RedvoxApiM_RedvoxPacketM.Sensors.Image {
      get {return _storage._image ?? RedvoxApiM_RedvoxPacketM.Sensors.Image()}
      set {_uniqueStorage()._image = newValue}
    }
    /// Returns true if `image` has been explicitly set.
    var hasImage: Bool {return _storage._image != nil}
    /// Clears the value of `image`. Subsequent reads from it will return its default value.
    mutating func clearImage() {_uniqueStorage()._image = nil}

    /// lux
    var light: RedvoxApiM_RedvoxPacketM.Sensors.Single {
      get {return _storage._light ?? RedvoxApiM_RedvoxPacketM.Sensors.Single()}
      set {_uniqueStorage()._light = newValue}
    }
    /// Returns true if `light` has been explicitly set.
    var hasLight: Bool {return _storage._light != nil}
    /// Clears the value of `light`. Subsequent reads from it will return its default value.
    mutating func clearLight() {_uniqueStorage()._light = nil}

    /// meters/second^2
    var linearAcceleration: RedvoxApiM_RedvoxPacketM.Sensors.Xyz {
      get {return _storage._linearAcceleration ?? RedvoxApiM_RedvoxPacketM.Sensors.Xyz()}
      set {_uniqueStorage()._linearAcceleration = newValue}
    }
    /// Returns true if `linearAcceleration` has been explicitly set.
    var hasLinearAcceleration: Bool {return _storage._linearAcceleration != nil}
    /// Clears the value of `linearAcceleration`. Subsequent reads from it will return its default value.
    mutating func clearLinearAcceleration() {_uniqueStorage()._linearAcceleration = nil}

    /// See standard
    var location: RedvoxApiM_RedvoxPacketM.Sensors.Location {
      get {return _storage._location ?? RedvoxApiM_RedvoxPacketM.Sensors.Location()}
      set {_uniqueStorage()._location = newValue}
    }
    /// Returns true if `location` has been explicitly set.
    var hasLocation: Bool {return _storage._location != nil}
    /// Clears the value of `location`. Subsequent reads from it will return its default value.
    mutating func clearLocation() {_uniqueStorage()._location = nil}

    /// microtesla
    var magnetometer: RedvoxApiM_RedvoxPacketM.Sensors.Xyz {
      get {return _storage._magnetometer ?? RedvoxApiM_RedvoxPacketM.Sensors.Xyz()}
      set {_uniqueStorage()._magnetometer = newValue}
    }
    /// Returns true if `magnetometer` has been explicitly set.
    var hasMagnetometer: Bool {return _storage._magnetometer != nil}
    /// Clears the value of `magnetometer`. Subsequent reads from it will return its default value.
    mutating func clearMagnetometer() {_uniqueStorage()._magnetometer = nil}

    /// radians
    var orientation: RedvoxApiM_RedvoxPacketM.Sensors.Xyz {
      get {return _storage._orientation ?? RedvoxApiM_RedvoxPacketM.Sensors.Xyz()}
      set {_uniqueStorage()._orientation = newValue}
    }
    /// Returns true if `orientation` has been explicitly set.
    var hasOrientation: Bool {return _storage._orientation != nil}
    /// Clears the value of `orientation`. Subsequent reads from it will return its default value.
    mutating func clearOrientation() {_uniqueStorage()._orientation = nil}

    /// kilopascal
    var pressure: RedvoxApiM_RedvoxPacketM.Sensors.Single {
      get {return _storage._pressure ?? RedvoxApiM_RedvoxPacketM.Sensors.Single()}
      set {_uniqueStorage()._pressure = newValue}
    }
    /// Returns true if `pressure` has been explicitly set.
    var hasPressure: Bool {return _storage._pressure != nil}
    /// Clears the value of `pressure`. Subsequent reads from it will return its default value.
    mutating func clearPressure() {_uniqueStorage()._pressure = nil}

    /// on, off, cm
    var proximity: RedvoxApiM_RedvoxPacketM.Sensors.Single {
      get {return _storage._proximity ?? RedvoxApiM_RedvoxPacketM.Sensors.Single()}
      set {_uniqueStorage()._proximity = newValue}
    }
    /// Returns true if `proximity` has been explicitly set.
    var hasProximity: Bool {return _storage._proximity != nil}
    /// Clears the value of `proximity`. Subsequent reads from it will return its default value.
    mutating func clearProximity() {_uniqueStorage()._proximity = nil}

    /// percentage
    var relativeHumidity: RedvoxApiM_RedvoxPacketM.Sensors.Single {
      get {return _storage._relativeHumidity ?? RedvoxApiM_RedvoxPacketM.Sensors.Single()}
      set {_uniqueStorage()._relativeHumidity = newValue}
    }
    /// Returns true if `relativeHumidity` has been explicitly set.
    var hasRelativeHumidity: Bool {return _storage._relativeHumidity != nil}
    /// Clears the value of `relativeHumidity`. Subsequent reads from it will return its default value.
    mutating func clearRelativeHumidity() {_uniqueStorage()._relativeHumidity = nil}

    /// Unitless
    var rotationVector: RedvoxApiM_RedvoxPacketM.Sensors.Xyz {
      get {return _storage._rotationVector ?? RedvoxApiM_RedvoxPacketM.Sensors.Xyz()}
      set {_uniqueStorage()._rotationVector = newValue}
    }
    /// Returns true if `rotationVector` has been explicitly set.
    var hasRotationVector: Bool {return _storage._rotationVector != nil}
    /// Clears the value of `rotationVector`. Subsequent reads from it will return its default value.
    mutating func clearRotationVector() {_uniqueStorage()._rotationVector = nil}

    /// A map from string to string for including untyped metadata
    var metadata: Dictionary<String,String> {
      get {return _storage._metadata}
      set {_uniqueStorage()._metadata = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// This message describes a stable audio channel
    /// See: https://github.com/RedVoxInc/redvox-api-1000/src/master/docs/standards/storing_audio_data.md
    struct Audio {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The name or description of the audio sensor
      var sensorDescription: String {
        get {return _storage._sensorDescription}
        set {_uniqueStorage()._sensorDescription = newValue}
      }

      /// Timestamp of the first audio sample
      var firstSampleTimestamp: Double {
        get {return _storage._firstSampleTimestamp}
        set {_uniqueStorage()._firstSampleTimestamp = newValue}
      }

      /// Microphone sample rate in Hz
      var sampleRate: Float {
        get {return _storage._sampleRate}
        set {_uniqueStorage()._sampleRate = newValue}
      }

      /// Bits of precision for normalized audio samples
      var bitsOfPrecision: Float {
        get {return _storage._bitsOfPrecision}
        set {_uniqueStorage()._bitsOfPrecision = newValue}
      }

      /// If audio data has been scrambled to remove voice
      var isScrambled: Bool {
        get {return _storage._isScrambled}
        set {_uniqueStorage()._isScrambled = newValue}
      }

      /// The audio encoding used... TODO: Turn this into an enum!
      var encoding: String {
        get {return _storage._encoding}
        set {_uniqueStorage()._encoding = newValue}
      }

      /// List of audio samples
      var samples: RedvoxApiM_RedvoxPacketM.SamplePayload {
        get {return _storage._samples ?? RedvoxApiM_RedvoxPacketM.SamplePayload()}
        set {_uniqueStorage()._samples = newValue}
      }
      /// Returns true if `samples` has been explicitly set.
      var hasSamples: Bool {return _storage._samples != nil}
      /// Clears the value of `samples`. Subsequent reads from it will return its default value.
      mutating func clearSamples() {_uniqueStorage()._samples = nil}

      /// A map from string to string for including untyped metadata
      var metadata: Dictionary<String,String> {
        get {return _storage._metadata}
        set {_uniqueStorage()._metadata = newValue}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    struct CompressedAudio {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The name or description of the audio sensor
      var sensorDescription: String = String()

      /// Mach timestamp of the first audio sample
      var firstSampleTimestamp: Double = 0

      /// Microphone sample rate in Hz
      var sampleRate: Float = 0

      /// If audio data has been scrambled to remove voice
      var isScrambled: Bool = false

      /// Bytes that make up audio payload
      var audioBytes: Data = Data()

      /// Codec used to compress audio
      var audioCodec: RedvoxApiM_RedvoxPacketM.Sensors.CompressedAudio.AudioCodec = .unknown

      /// A map from string to string for including untyped metadata
      var metadata: Dictionary<String,String> = [:]

      var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Available audio codecs
      enum AudioCodec: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case unknown // = 0
        case flac // = 1
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .flac
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .flac: return 1
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      init() {}
    }

    /// A single channel of data
    /// See: https://github.com/RedVoxInc/redvox-api-1000/src/master/docs/standards/storing_single_channel_data.md
    struct Single {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The name or description of the sensor
      var sensorDescription: String {
        get {return _storage._sensorDescription}
        set {_uniqueStorage()._sensorDescription = newValue}
      }

      /// List of timestamps per sample and associated stats
      var timestamps: RedvoxApiM_RedvoxPacketM.TimingPayload {
        get {return _storage._timestamps ?? RedvoxApiM_RedvoxPacketM.TimingPayload()}
        set {_uniqueStorage()._timestamps = newValue}
      }
      /// Returns true if `timestamps` has been explicitly set.
      var hasTimestamps: Bool {return _storage._timestamps != nil}
      /// Clears the value of `timestamps`. Subsequent reads from it will return its default value.
      mutating func clearTimestamps() {_uniqueStorage()._timestamps = nil}

      /// List of samples and associated stats
      var samples: RedvoxApiM_RedvoxPacketM.SamplePayload {
        get {return _storage._samples ?? RedvoxApiM_RedvoxPacketM.SamplePayload()}
        set {_uniqueStorage()._samples = newValue}
      }
      /// Returns true if `samples` has been explicitly set.
      var hasSamples: Bool {return _storage._samples != nil}
      /// Clears the value of `samples`. Subsequent reads from it will return its default value.
      mutating func clearSamples() {_uniqueStorage()._samples = nil}

      /// A map from string to string for including untyped metadata
      var metadata: Dictionary<String,String> {
        get {return _storage._metadata}
        set {_uniqueStorage()._metadata = newValue}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    /// Location channels
    /// See: https://github.com/RedVoxInc/redvox-api-1000/src/master/docs/standards/storing_location_data.md
    struct Location {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The name or description of the sensor
      var sensorDescription: String {
        get {return _storage._sensorDescription}
        set {_uniqueStorage()._sensorDescription = newValue}
      }

      /// Timestamps and stats
      var timestamps: RedvoxApiM_RedvoxPacketM.TimingPayload {
        get {return _storage._timestamps ?? RedvoxApiM_RedvoxPacketM.TimingPayload()}
        set {_uniqueStorage()._timestamps = newValue}
      }
      /// Returns true if `timestamps` has been explicitly set.
      var hasTimestamps: Bool {return _storage._timestamps != nil}
      /// Clears the value of `timestamps`. Subsequent reads from it will return its default value.
      mutating func clearTimestamps() {_uniqueStorage()._timestamps = nil}

      var timestampsGps: RedvoxApiM_RedvoxPacketM.TimingPayload {
        get {return _storage._timestampsGps ?? RedvoxApiM_RedvoxPacketM.TimingPayload()}
        set {_uniqueStorage()._timestampsGps = newValue}
      }
      /// Returns true if `timestampsGps` has been explicitly set.
      var hasTimestampsGps: Bool {return _storage._timestampsGps != nil}
      /// Clears the value of `timestampsGps`. Subsequent reads from it will return its default value.
      mutating func clearTimestampsGps() {_uniqueStorage()._timestampsGps = nil}

      /// A list of latitude samples
      var latitudeSamples: RedvoxApiM_RedvoxPacketM.DoubleSamplePayload {
        get {return _storage._latitudeSamples ?? RedvoxApiM_RedvoxPacketM.DoubleSamplePayload()}
        set {_uniqueStorage()._latitudeSamples = newValue}
      }
      /// Returns true if `latitudeSamples` has been explicitly set.
      var hasLatitudeSamples: Bool {return _storage._latitudeSamples != nil}
      /// Clears the value of `latitudeSamples`. Subsequent reads from it will return its default value.
      mutating func clearLatitudeSamples() {_uniqueStorage()._latitudeSamples = nil}

      /// A list of longitude samples
      var longitudeSamples: RedvoxApiM_RedvoxPacketM.DoubleSamplePayload {
        get {return _storage._longitudeSamples ?? RedvoxApiM_RedvoxPacketM.DoubleSamplePayload()}
        set {_uniqueStorage()._longitudeSamples = newValue}
      }
      /// Returns true if `longitudeSamples` has been explicitly set.
      var hasLongitudeSamples: Bool {return _storage._longitudeSamples != nil}
      /// Clears the value of `longitudeSamples`. Subsequent reads from it will return its default value.
      mutating func clearLongitudeSamples() {_uniqueStorage()._longitudeSamples = nil}

      /// A list of altitude samples
      var altitudeSamples: RedvoxApiM_RedvoxPacketM.SamplePayload {
        get {return _storage._altitudeSamples ?? RedvoxApiM_RedvoxPacketM.SamplePayload()}
        set {_uniqueStorage()._altitudeSamples = newValue}
      }
      /// Returns true if `altitudeSamples` has been explicitly set.
      var hasAltitudeSamples: Bool {return _storage._altitudeSamples != nil}
      /// Clears the value of `altitudeSamples`. Subsequent reads from it will return its default value.
      mutating func clearAltitudeSamples() {_uniqueStorage()._altitudeSamples = nil}

      /// A list of speed samples
      var speedSamples: RedvoxApiM_RedvoxPacketM.SamplePayload {
        get {return _storage._speedSamples ?? RedvoxApiM_RedvoxPacketM.SamplePayload()}
        set {_uniqueStorage()._speedSamples = newValue}
      }
      /// Returns true if `speedSamples` has been explicitly set.
      var hasSpeedSamples: Bool {return _storage._speedSamples != nil}
      /// Clears the value of `speedSamples`. Subsequent reads from it will return its default value.
      mutating func clearSpeedSamples() {_uniqueStorage()._speedSamples = nil}

      /// A list of bearing samples
      var bearingSamples: RedvoxApiM_RedvoxPacketM.SamplePayload {
        get {return _storage._bearingSamples ?? RedvoxApiM_RedvoxPacketM.SamplePayload()}
        set {_uniqueStorage()._bearingSamples = newValue}
      }
      /// Returns true if `bearingSamples` has been explicitly set.
      var hasBearingSamples: Bool {return _storage._bearingSamples != nil}
      /// Clears the value of `bearingSamples`. Subsequent reads from it will return its default value.
      mutating func clearBearingSamples() {_uniqueStorage()._bearingSamples = nil}

      /// A list of horizontal accuracy samples
      var horizontalAccuracySamples: RedvoxApiM_RedvoxPacketM.SamplePayload {
        get {return _storage._horizontalAccuracySamples ?? RedvoxApiM_RedvoxPacketM.SamplePayload()}
        set {_uniqueStorage()._horizontalAccuracySamples = newValue}
      }
      /// Returns true if `horizontalAccuracySamples` has been explicitly set.
      var hasHorizontalAccuracySamples: Bool {return _storage._horizontalAccuracySamples != nil}
      /// Clears the value of `horizontalAccuracySamples`. Subsequent reads from it will return its default value.
      mutating func clearHorizontalAccuracySamples() {_uniqueStorage()._horizontalAccuracySamples = nil}

      /// A list of vertical accuracy samples
      var verticalAccuracySamples: RedvoxApiM_RedvoxPacketM.SamplePayload {
        get {return _storage._verticalAccuracySamples ?? RedvoxApiM_RedvoxPacketM.SamplePayload()}
        set {_uniqueStorage()._verticalAccuracySamples = newValue}
      }
      /// Returns true if `verticalAccuracySamples` has been explicitly set.
      var hasVerticalAccuracySamples: Bool {return _storage._verticalAccuracySamples != nil}
      /// Clears the value of `verticalAccuracySamples`. Subsequent reads from it will return its default value.
      mutating func clearVerticalAccuracySamples() {_uniqueStorage()._verticalAccuracySamples = nil}

      /// A list of speed accuracy samples
      var speedAccuracySamples: RedvoxApiM_RedvoxPacketM.SamplePayload {
        get {return _storage._speedAccuracySamples ?? RedvoxApiM_RedvoxPacketM.SamplePayload()}
        set {_uniqueStorage()._speedAccuracySamples = newValue}
      }
      /// Returns true if `speedAccuracySamples` has been explicitly set.
      var hasSpeedAccuracySamples: Bool {return _storage._speedAccuracySamples != nil}
      /// Clears the value of `speedAccuracySamples`. Subsequent reads from it will return its default value.
      mutating func clearSpeedAccuracySamples() {_uniqueStorage()._speedAccuracySamples = nil}

      /// A list of bearing accuracy samples
      var bearingAccuracySamples: RedvoxApiM_RedvoxPacketM.SamplePayload {
        get {return _storage._bearingAccuracySamples ?? RedvoxApiM_RedvoxPacketM.SamplePayload()}
        set {_uniqueStorage()._bearingAccuracySamples = newValue}
      }
      /// Returns true if `bearingAccuracySamples` has been explicitly set.
      var hasBearingAccuracySamples: Bool {return _storage._bearingAccuracySamples != nil}
      /// Clears the value of `bearingAccuracySamples`. Subsequent reads from it will return its default value.
      mutating func clearBearingAccuracySamples() {_uniqueStorage()._bearingAccuracySamples = nil}

      /// Most recent best location
      var lastBestLocation: RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation {
        get {return _storage._lastBestLocation ?? RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation()}
        set {_uniqueStorage()._lastBestLocation = newValue}
      }
      /// Returns true if `lastBestLocation` has been explicitly set.
      var hasLastBestLocation: Bool {return _storage._lastBestLocation != nil}
      /// Clears the value of `lastBestLocation`. Subsequent reads from it will return its default value.
      mutating func clearLastBestLocation() {_uniqueStorage()._lastBestLocation = nil}

      /// Best last location
      var overallBestLocation: RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation {
        get {return _storage._overallBestLocation ?? RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation()}
        set {_uniqueStorage()._overallBestLocation = newValue}
      }
      /// Returns true if `overallBestLocation` has been explicitly set.
      var hasOverallBestLocation: Bool {return _storage._overallBestLocation != nil}
      /// Clears the value of `overallBestLocation`. Subsequent reads from it will return its default value.
      mutating func clearOverallBestLocation() {_uniqueStorage()._overallBestLocation = nil}

      /// Have location permissions been granted by the user?
      var locationPermissionsGranted: Bool {
        get {return _storage._locationPermissionsGranted}
        set {_uniqueStorage()._locationPermissionsGranted = newValue}
      }

      /// Has location services been requested by the user?
      var locationServicesRequested: Bool {
        get {return _storage._locationServicesRequested}
        set {_uniqueStorage()._locationServicesRequested = newValue}
      }

      /// Are location services enabled and working?
      var locationServicesEnabled: Bool {
        get {return _storage._locationServicesEnabled}
        set {_uniqueStorage()._locationServicesEnabled = newValue}
      }

      /// Location provider enumeration
      var locationProviders: [RedvoxApiM_RedvoxPacketM.Sensors.Location.LocationProvider] {
        get {return _storage._locationProviders}
        set {_uniqueStorage()._locationProviders = newValue}
      }

      /// A map from string to string for including untyped metadata
      var metadata: Dictionary<String,String> {
        get {return _storage._metadata}
        set {_uniqueStorage()._metadata = newValue}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      /// An enumeration of location providers
      enum LocationProvider: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case unknown // = 0
        case none // = 1
        case user // = 2
        case gps // = 3
        case network // = 4
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .none
          case 2: self = .user
          case 3: self = .gps
          case 4: self = .network
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .none: return 1
          case .user: return 2
          case .gps: return 3
          case .network: return 4
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      struct BestLocation {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// Timestamp of best lat/lng measurement
        var latitudeLongitudeTimestamp: RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation.BestTimestamp {
          get {return _storage._latitudeLongitudeTimestamp ?? RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation.BestTimestamp()}
          set {_uniqueStorage()._latitudeLongitudeTimestamp = newValue}
        }
        /// Returns true if `latitudeLongitudeTimestamp` has been explicitly set.
        var hasLatitudeLongitudeTimestamp: Bool {return _storage._latitudeLongitudeTimestamp != nil}
        /// Clears the value of `latitudeLongitudeTimestamp`. Subsequent reads from it will return its default value.
        mutating func clearLatitudeLongitudeTimestamp() {_uniqueStorage()._latitudeLongitudeTimestamp = nil}

        /// Timestamp of best altitude measurement
        var altitudeTimestamp: RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation.BestTimestamp {
          get {return _storage._altitudeTimestamp ?? RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation.BestTimestamp()}
          set {_uniqueStorage()._altitudeTimestamp = newValue}
        }
        /// Returns true if `altitudeTimestamp` has been explicitly set.
        var hasAltitudeTimestamp: Bool {return _storage._altitudeTimestamp != nil}
        /// Clears the value of `altitudeTimestamp`. Subsequent reads from it will return its default value.
        mutating func clearAltitudeTimestamp() {_uniqueStorage()._altitudeTimestamp = nil}

        /// Timestamp of best speed measurement
        var speedTimestamp: RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation.BestTimestamp {
          get {return _storage._speedTimestamp ?? RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation.BestTimestamp()}
          set {_uniqueStorage()._speedTimestamp = newValue}
        }
        /// Returns true if `speedTimestamp` has been explicitly set.
        var hasSpeedTimestamp: Bool {return _storage._speedTimestamp != nil}
        /// Clears the value of `speedTimestamp`. Subsequent reads from it will return its default value.
        mutating func clearSpeedTimestamp() {_uniqueStorage()._speedTimestamp = nil}

        /// Timestamp of best bearing estimate
        var bearingTimestamp: RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation.BestTimestamp {
          get {return _storage._bearingTimestamp ?? RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation.BestTimestamp()}
          set {_uniqueStorage()._bearingTimestamp = newValue}
        }
        /// Returns true if `bearingTimestamp` has been explicitly set.
        var hasBearingTimestamp: Bool {return _storage._bearingTimestamp != nil}
        /// Clears the value of `bearingTimestamp`. Subsequent reads from it will return its default value.
        mutating func clearBearingTimestamp() {_uniqueStorage()._bearingTimestamp = nil}

        /// Unit used for latitude/longitude (should be decimal degrees)
        var latitudeLongitudeUnit: RedvoxApiM_RedvoxPacketM.Unit {
          get {return _storage._latitudeLongitudeUnit}
          set {_uniqueStorage()._latitudeLongitudeUnit = newValue}
        }

        /// Unit used for altitude (should be meters)
        var altitudeUnit: RedvoxApiM_RedvoxPacketM.Unit {
          get {return _storage._altitudeUnit}
          set {_uniqueStorage()._altitudeUnit = newValue}
        }

        /// Unit used for speed (should be m/s)
        var speedUnit: RedvoxApiM_RedvoxPacketM.Unit {
          get {return _storage._speedUnit}
          set {_uniqueStorage()._speedUnit = newValue}
        }

        /// Unit used for bearing (should be radians)
        var bearingUnit: RedvoxApiM_RedvoxPacketM.Unit {
          get {return _storage._bearingUnit}
          set {_uniqueStorage()._bearingUnit = newValue}
        }

        /// Unit used for vertical accuracy
        var verticalAccuracyUnit: RedvoxApiM_RedvoxPacketM.Unit {
          get {return _storage._verticalAccuracyUnit}
          set {_uniqueStorage()._verticalAccuracyUnit = newValue}
        }

        /// Unit used for horizontal accuracy
        var horizontalAccuracyUnit: RedvoxApiM_RedvoxPacketM.Unit {
          get {return _storage._horizontalAccuracyUnit}
          set {_uniqueStorage()._horizontalAccuracyUnit = newValue}
        }

        /// Unit used for speed accuracy
        var speedAccuracyUnit: RedvoxApiM_RedvoxPacketM.Unit {
          get {return _storage._speedAccuracyUnit}
          set {_uniqueStorage()._speedAccuracyUnit = newValue}
        }

        /// Unit used for bearing accuracy
        var bearingAccuracyUnit: RedvoxApiM_RedvoxPacketM.Unit {
          get {return _storage._bearingAccuracyUnit}
          set {_uniqueStorage()._bearingAccuracyUnit = newValue}
        }

        /// The best latitude
        var latitude: Double {
          get {return _storage._latitude}
          set {_uniqueStorage()._latitude = newValue}
        }

        /// The best longitude
        var longitude: Double {
          get {return _storage._longitude}
          set {_uniqueStorage()._longitude = newValue}
        }

        /// The best altitude
        var altitude: Float {
          get {return _storage._altitude}
          set {_uniqueStorage()._altitude = newValue}
        }

        /// The best speed
        var speed: Float {
          get {return _storage._speed}
          set {_uniqueStorage()._speed = newValue}
        }

        /// The best bearing
        var bearing: Float {
          get {return _storage._bearing}
          set {_uniqueStorage()._bearing = newValue}
        }

        /// Vertical accuracy
        var verticalAccuracy: Float {
          get {return _storage._verticalAccuracy}
          set {_uniqueStorage()._verticalAccuracy = newValue}
        }

        /// Horizontal accuracy
        var horizontalAccuracy: Float {
          get {return _storage._horizontalAccuracy}
          set {_uniqueStorage()._horizontalAccuracy = newValue}
        }

        /// Speed accuracy
        var speedAccuracy: Float {
          get {return _storage._speedAccuracy}
          set {_uniqueStorage()._speedAccuracy = newValue}
        }

        /// Bearing accuracy
        var bearingAccuracy: Float {
          get {return _storage._bearingAccuracy}
          set {_uniqueStorage()._bearingAccuracy = newValue}
        }

        /// The best location score
        var score: Float {
          get {return _storage._score}
          set {_uniqueStorage()._score = newValue}
        }

        /// Method used to derive the location score
        var method: RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation.LocationScoreMethod {
          get {return _storage._method}
          set {_uniqueStorage()._method = newValue}
        }

        var locationProvider: RedvoxApiM_RedvoxPacketM.Sensors.Location.LocationProvider {
          get {return _storage._locationProvider}
          set {_uniqueStorage()._locationProvider = newValue}
        }

        /// A map from string to string for including untyped metadata
        var metadata: Dictionary<String,String> {
          get {return _storage._metadata}
          set {_uniqueStorage()._metadata = newValue}
        }

        var unknownFields = SwiftProtobuf.UnknownStorage()

        /// An enumeration for the various scoring methods for the "best of" metrics
        enum LocationScoreMethod: SwiftProtobuf.Enum {
          typealias RawValue = Int
          case unknownMethod // = 0
          case UNRECOGNIZED(Int)

          init() {
            self = .unknownMethod
          }

          init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .unknownMethod
            default: self = .UNRECOGNIZED(rawValue)
            }
          }

          var rawValue: Int {
            switch self {
            case .unknownMethod: return 0
            case .UNRECOGNIZED(let i): return i
            }
          }

        }

        /// A message that encapsulates both a mach and GPS timestamp
        struct BestTimestamp {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          /// Unit of timestamps (should be microseconds since unix epoch UTC)
          var unit: RedvoxApiM_RedvoxPacketM.Unit = .unknown

          /// Best mach timestamp
          var mach: Double = 0

          /// Best gps timestamp
          var gps: Double = 0

          /// A map from string to string for including untyped metadata
          var metadata: Dictionary<String,String> = [:]

          var unknownFields = SwiftProtobuf.UnknownStorage()

          init() {}
        }

        init() {}

        fileprivate var _storage = _StorageClass.defaultInstance
      }

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    /// Message representing data channels with X, Y, and Z components
    /// See: https://github.com/RedVoxInc/redvox-api-1000/src/master/docs/standards/storing_xyz_channel_data.md
    struct Xyz {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The name or description of the sensor
      var sensorDescription: String {
        get {return _storage._sensorDescription}
        set {_uniqueStorage()._sensorDescription = newValue}
      }

      /// List of timestamps per sample
      var timestamps: RedvoxApiM_RedvoxPacketM.TimingPayload {
        get {return _storage._timestamps ?? RedvoxApiM_RedvoxPacketM.TimingPayload()}
        set {_uniqueStorage()._timestamps = newValue}
      }
      /// Returns true if `timestamps` has been explicitly set.
      var hasTimestamps: Bool {return _storage._timestamps != nil}
      /// Clears the value of `timestamps`. Subsequent reads from it will return its default value.
      mutating func clearTimestamps() {_uniqueStorage()._timestamps = nil}

      /// A list of samples for the X-channel
      var xSamples: RedvoxApiM_RedvoxPacketM.SamplePayload {
        get {return _storage._xSamples ?? RedvoxApiM_RedvoxPacketM.SamplePayload()}
        set {_uniqueStorage()._xSamples = newValue}
      }
      /// Returns true if `xSamples` has been explicitly set.
      var hasXSamples: Bool {return _storage._xSamples != nil}
      /// Clears the value of `xSamples`. Subsequent reads from it will return its default value.
      mutating func clearXSamples() {_uniqueStorage()._xSamples = nil}

      /// A list of samples for the Y-channel
      var ySamples: RedvoxApiM_RedvoxPacketM.SamplePayload {
        get {return _storage._ySamples ?? RedvoxApiM_RedvoxPacketM.SamplePayload()}
        set {_uniqueStorage()._ySamples = newValue}
      }
      /// Returns true if `ySamples` has been explicitly set.
      var hasYSamples: Bool {return _storage._ySamples != nil}
      /// Clears the value of `ySamples`. Subsequent reads from it will return its default value.
      mutating func clearYSamples() {_uniqueStorage()._ySamples = nil}

      /// A list of samples for the Z-channel
      var zSamples: RedvoxApiM_RedvoxPacketM.SamplePayload {
        get {return _storage._zSamples ?? RedvoxApiM_RedvoxPacketM.SamplePayload()}
        set {_uniqueStorage()._zSamples = newValue}
      }
      /// Returns true if `zSamples` has been explicitly set.
      var hasZSamples: Bool {return _storage._zSamples != nil}
      /// Clears the value of `zSamples`. Subsequent reads from it will return its default value.
      mutating func clearZSamples() {_uniqueStorage()._zSamples = nil}

      /// A map from string to string for including untyped metadata
      var metadata: Dictionary<String,String> {
        get {return _storage._metadata}
        set {_uniqueStorage()._metadata = newValue}
      }

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    /// Image/video channel
    /// See: https://github.com/RedVoxInc/redvox-api-1000/src/master/docs/standards/storing_image_data.md
    struct Image {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The name or description of the sensor
      var sensorDescription: String = String()

      /// Timestamps per sample
      var timestamps: RedvoxApiM_RedvoxPacketM.TimingPayload {
        get {return _timestamps ?? RedvoxApiM_RedvoxPacketM.TimingPayload()}
        set {_timestamps = newValue}
      }
      /// Returns true if `timestamps` has been explicitly set.
      var hasTimestamps: Bool {return self._timestamps != nil}
      /// Clears the value of `timestamps`. Subsequent reads from it will return its default value.
      mutating func clearTimestamps() {self._timestamps = nil}

      /// A list of bytes each representing a single image
      var samples: [Data] = []

      /// The image codec being used
      var imageCodec: RedvoxApiM_RedvoxPacketM.Sensors.Image.ImageCodec = .unknown

      /// A map from string to string for including untyped metadata
      var metadata: Dictionary<String,String> = [:]

      var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Codec used to encode the image
      enum ImageCodec: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case unknown // = 0
        case png // = 1
        case jpg // = 2
        case bmp // = 3
        case UNRECOGNIZED(Int)

        init() {
          self = .unknown
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unknown
          case 1: self = .png
          case 2: self = .jpg
          case 3: self = .bmp
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .unknown: return 0
          case .png: return 1
          case .jpg: return 2
          case .bmp: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      init() {}

      fileprivate var _timestamps: RedvoxApiM_RedvoxPacketM.TimingPayload? = nil
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// Provides a mechanism for storing various generic derived events
  struct EventStream {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of this stream
    var name: String = String()

    /// List of timestamps, each associated with one Event
    var timestamps: RedvoxApiM_RedvoxPacketM.TimingPayload {
      get {return _timestamps ?? RedvoxApiM_RedvoxPacketM.TimingPayload()}
      set {_timestamps = newValue}
    }
    /// Returns true if `timestamps` has been explicitly set.
    var hasTimestamps: Bool {return self._timestamps != nil}
    /// Clears the value of `timestamps`. Subsequent reads from it will return its default value.
    mutating func clearTimestamps() {self._timestamps = nil}

    /// List of events that belong to this stream
    var events: [RedvoxApiM_RedvoxPacketM.EventStream.Event] = []

    /// A map from string to string for including untyped metadata
    var metadata: Dictionary<String,String> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Event {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Textual description of the event
      var description_p: String = String()

      /// Key-pairs of type string to string
      var stringPayload: Dictionary<String,String> = [:]

      /// Key-pairs of type string to double
      var numericPayload: Dictionary<String,Double> = [:]

      /// Key-pairs of type string to boolean
      var booleanPayload: Dictionary<String,Bool> = [:]

      /// Key-pairs of type string to bytes.
      /// This one is mainly for transmitting binary or data that doesn't fit well into one of the other payloads.
      var bytePayload: Dictionary<String,Data> = [:]

      /// A map from string to string for including untyped metadata
      var metadata: Dictionary<String,String> = [:]

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}

    fileprivate var _timestamps: RedvoxApiM_RedvoxPacketM.TimingPayload? = nil
  }

  /// Combines a unit, sample values, and value statistics
  /// Used to store collections of samples, their unit, and the statistics for those samples.
  struct SamplePayload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Unit of payload values
    var unit: RedvoxApiM_RedvoxPacketM.Unit = .unknown

    /// Values in payload
    var values: [Float] = []

    /// Statistics of stored values
    var valueStatistics: RedvoxApiM_RedvoxPacketM.SummaryStatistics {
      get {return _valueStatistics ?? RedvoxApiM_RedvoxPacketM.SummaryStatistics()}
      set {_valueStatistics = newValue}
    }
    /// Returns true if `valueStatistics` has been explicitly set.
    var hasValueStatistics: Bool {return self._valueStatistics != nil}
    /// Clears the value of `valueStatistics`. Subsequent reads from it will return its default value.
    mutating func clearValueStatistics() {self._valueStatistics = nil}

    /// A map from string to string for including untyped metadata
    var metadata: Dictionary<String,String> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _valueStatistics: RedvoxApiM_RedvoxPacketM.SummaryStatistics? = nil
  }

  /// Exactly like a SamplePayload, but payload values are 64-bit floats rather than 32-bit floats.
  struct DoubleSamplePayload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Unit of payload values
    var unit: RedvoxApiM_RedvoxPacketM.Unit = .unknown

    /// Values in payload
    var values: [Double] = []

    /// Statistics of stored values
    var valueStatistics: RedvoxApiM_RedvoxPacketM.SummaryStatistics {
      get {return _valueStatistics ?? RedvoxApiM_RedvoxPacketM.SummaryStatistics()}
      set {_valueStatistics = newValue}
    }
    /// Returns true if `valueStatistics` has been explicitly set.
    var hasValueStatistics: Bool {return self._valueStatistics != nil}
    /// Clears the value of `valueStatistics`. Subsequent reads from it will return its default value.
    mutating func clearValueStatistics() {self._valueStatistics = nil}

    /// A map from string to string for including untyped metadata
    var metadata: Dictionary<String,String> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _valueStatistics: RedvoxApiM_RedvoxPacketM.SummaryStatistics? = nil
  }

  /// Combines a unit, sample values, and value statistics
  /// Used to store collections of samples, their unit, and the statistics for those samples.
  struct TimingPayload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Unit of payload values
    var unit: RedvoxApiM_RedvoxPacketM.Unit = .unknown

    /// Values in payload
    var timestamps: [Double] = []

    /// Statistics of stored values
    var timestampStatistics: RedvoxApiM_RedvoxPacketM.SummaryStatistics {
      get {return _timestampStatistics ?? RedvoxApiM_RedvoxPacketM.SummaryStatistics()}
      set {_timestampStatistics = newValue}
    }
    /// Returns true if `timestampStatistics` has been explicitly set.
    var hasTimestampStatistics: Bool {return self._timestampStatistics != nil}
    /// Clears the value of `timestampStatistics`. Subsequent reads from it will return its default value.
    mutating func clearTimestampStatistics() {self._timestampStatistics = nil}

    /// Mean sample rate in Hz
    var meanSampleRate: Float = 0

    /// Standard deviation of sample rate in Hz
    var stdevSampleRate: Float = 0

    /// A map from string to string for including untyped metadata
    var metadata: Dictionary<String,String> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _timestampStatistics: RedvoxApiM_RedvoxPacketM.SummaryStatistics? = nil
  }

  /// Common statistics stored with payloads
  struct SummaryStatistics {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The total count of values included in the statistics
    var count: Double = 0

    /// The mean of the values
    var mean: Double = 0

    /// The standard deviation of the values
    var standardDeviation: Double = 0

    /// The minimum value
    var min: Double = 0

    /// The maximum value
    var max: Double = 0

    /// The range of the values
    var range: Double = 0

    /// A map from string to string for including untyped metadata
    var metadata: Dictionary<String,String> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension RedvoxApiM_RedvoxPacketM.Unit: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RedvoxApiM_RedvoxPacketM.Unit] = [
    .unknown,
    .metersPerSecondSquared,
    .kilopascal,
    .radiansPerSecond,
    .decimalDegrees,
    .meters,
    .metersPerSecond,
    .microtesla,
    .lsbPlusMinusCounts,
    .microsecondsSinceUnixEpoch,
    .decibel,
    .degreesCelsius,
    .byte,
    .percentage,
    .radians,
    .microamperes,
    .centimeters,
    .normalizedCounts,
    .lux,
    .less,
    .pcm,
  ]
}

extension RedvoxApiM_RedvoxPacketM.StationInformation.OsType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RedvoxApiM_RedvoxPacketM.StationInformation.OsType] = [
    .unknownOs,
    .android,
    .ios,
    .osx,
    .linux,
    .windows,
  ]
}

extension RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics.NetworkType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics.NetworkType] = [
    .unknownNetwork,
    .noNetwork,
    .wifi,
    .cellular,
    .wired,
  ]
}

extension RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics.WifiWakeLock: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics.WifiWakeLock] = [
    .none,
    .highPerf,
    .lowLatency,
    .other,
  ]
}

extension RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics.CellServiceState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics.CellServiceState] = [
    .unknown,
    .emergency,
    .nominal,
    .outOfService,
    .powerOff,
  ]
}

extension RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics.PowerState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics.PowerState] = [
    .unknownPowerState,
    .unplugged,
    .charging,
    .charged,
  ]
}

extension RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings.FftOverlap: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings.FftOverlap] = [
    .unknown,
    .percent25,
    .percent50,
    .percent75,
  ]
}

extension RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings.AudioSamplingRate: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings.AudioSamplingRate] = [
    .unknownSamplingRate,
    .hz80,
    .hz800,
    .hz8000,
    .hz16000,
    .hz48000,
  ]
}

extension RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings.AudioSourceTuning: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings.AudioSourceTuning] = [
    .unknownTuning,
    .infrasoundTuning,
    .lowAudioTuning,
    .audioTuning,
  ]
}

extension RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings.InputSensor: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings.InputSensor] = [
    .unknownSensor,
    .accelerometer,
    .ambientTemperature,
    .audio,
    .compressedAudio,
    .gravity,
    .gyroscope,
    .image,
    .light,
    .linearAcceleration,
    .location,
    .magnetometer,
    .orientation,
    .pressure,
    .proximity,
    .relativeHumidity,
    .rotationVector,
  ]
}

extension RedvoxApiM_RedvoxPacketM.TimingInformation.TimingScoreMethod: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RedvoxApiM_RedvoxPacketM.TimingInformation.TimingScoreMethod] = [
    .unknown,
  ]
}

extension RedvoxApiM_RedvoxPacketM.Sensors.CompressedAudio.AudioCodec: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RedvoxApiM_RedvoxPacketM.Sensors.CompressedAudio.AudioCodec] = [
    .unknown,
    .flac,
  ]
}

extension RedvoxApiM_RedvoxPacketM.Sensors.Location.LocationProvider: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RedvoxApiM_RedvoxPacketM.Sensors.Location.LocationProvider] = [
    .unknown,
    .none,
    .user,
    .gps,
    .network,
  ]
}

extension RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation.LocationScoreMethod: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation.LocationScoreMethod] = [
    .unknownMethod,
  ]
}

extension RedvoxApiM_RedvoxPacketM.Sensors.Image.ImageCodec: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RedvoxApiM_RedvoxPacketM.Sensors.Image.ImageCodec] = [
    .unknown,
    .png,
    .jpg,
    .bmp,
  ]
}

#endif  // swift(>=4.2)

/// Message type for providing E2E encryption.
/// The header is encrypted via RedVox keys.
/// The body is encrypted via user keys.
/// Each payload consists of bytes from the following transformations
///   Serialization: Object -> serialize to bytes -> LZ4 frame compress -> encrypt -> payload bytes
///   Deserialization: Payload bytes -> decrypt -> LZ4 frame decompress -> deserialize from bytes -> object
struct RedvoxApiM_EncryptedRedvoxPacketM {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// redvox encrypt(compress(EncryptedRedvoxPacket1000.Header))
  var header: Data = Data()

  /// user encrypt(compress(RedvoxPacketApi1000))
  var packet: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Header {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The station id
    var stationID: String = String()

    /// The station uuid
    var stationUuid: String = String()

    /// The station's authorization token
    var authToken: String = String()

    /// The station's firebase token
    var firebaseToken: String = String()

    /// The station's auth email
    var authEmail: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// --------- Message types for communicating with RedVox data acquisition servers
/// Message for sending RedVox data to a redvox.io data acquisition service.
struct RedvoxApiM_AcquisitionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The server provided authentication token
  var authToken: String = String()

  /// The API provided firebase token
  var firebaseToken: String = String()

  /// A checksum of the payload bytes
  var checksum: Int64 = 0

  /// If set, then the payload contains
  var isEncrypted: Bool = false

  /// The compressed packet to send
  var payload: Data = Data()

  /// A variable that starts at 0 when the data stream starts and increments by one for each transmission
  var seqID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Response from data acquisition services.
struct RedvoxApiM_AcquisitionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Response type (as above)
  var responseType: RedvoxApiM_AcquisitionResponse.ResponseType = .unknown

  /// Checksum computed by server
  var checksum: Int64 = 0

  /// Any other error details
  var details: String = String()

  /// If set, client to should attempt to resend the file
  /// otherwise, don't resend the file.
  var resend: Bool = false

  /// A copy of the seq_id provided in the AcquisitionRequest
  var seqID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ResponseType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unknown (default) response type
    case unknown // = 0

    /// No issues with packet
    case ok // = 1

    /// An authentication error has occurred
    case authError // = 2

    /// An error with the data decoding or data quality
    case dataError // = 3

    /// Any other errors
    case otherError // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .authError
      case 3: self = .dataError
      case 4: self = .otherError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .authError: return 2
      case .dataError: return 3
      case .otherError: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension RedvoxApiM_AcquisitionResponse.ResponseType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [RedvoxApiM_AcquisitionResponse.ResponseType] = [
    .unknown,
    .ok,
    .authError,
    .dataError,
    .otherError,
  ]
}

#endif  // swift(>=4.2)

/// --------- Message types for communicating with RedVox v3 time synchronization service
struct RedvoxApiM_SynchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Id of the station
  var stationID: String = String()

  /// Uuid of the station
  var stationUuid: String = String()

  /// The overall number of synch requests made. Starts at 0 on recording start.
  var seqID: UInt32 = 0

  /// The seq id within a single exchange
  var subSeqID: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RedvoxApiM_SynchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Should match same field from request
  var stationID: String = String()

  /// Should match same field from request
  var stationUuid: String = String()

  /// Should match same field from request
  var seqID: UInt32 = 0

  /// Should be req field + 1
  var subSeqID: UInt32 = 0

  /// Time synch server received request
  var recvTsUs: UInt64 = 0

  /// Time synch server sent response
  var sendTsUs: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "redvox_api_m"

extension RedvoxApiM_RedvoxPacketM: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RedvoxPacketM"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "api"),
    2: .standard(proto: "sub_api"),
    3: .standard(proto: "station_information"),
    4: .standard(proto: "timing_information"),
    5: .same(proto: "sensors"),
    6: .standard(proto: "event_streams"),
    7: .same(proto: "metadata"),
  ]

  fileprivate class _StorageClass {
    var _api: Float = 0
    var _subApi: Float = 0
    var _stationInformation: RedvoxApiM_RedvoxPacketM.StationInformation? = nil
    var _timingInformation: RedvoxApiM_RedvoxPacketM.TimingInformation? = nil
    var _sensors: RedvoxApiM_RedvoxPacketM.Sensors? = nil
    var _eventStreams: [RedvoxApiM_RedvoxPacketM.EventStream] = []
    var _metadata: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _api = source._api
      _subApi = source._subApi
      _stationInformation = source._stationInformation
      _timingInformation = source._timingInformation
      _sensors = source._sensors
      _eventStreams = source._eventStreams
      _metadata = source._metadata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularFloatField(value: &_storage._api) }()
        case 2: try { try decoder.decodeSingularFloatField(value: &_storage._subApi) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._stationInformation) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._timingInformation) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._sensors) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._eventStreams) }()
        case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._metadata) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._api != 0 {
        try visitor.visitSingularFloatField(value: _storage._api, fieldNumber: 1)
      }
      if _storage._subApi != 0 {
        try visitor.visitSingularFloatField(value: _storage._subApi, fieldNumber: 2)
      }
      if let v = _storage._stationInformation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._timingInformation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._sensors {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._eventStreams.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._eventStreams, fieldNumber: 6)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._metadata, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_RedvoxPacketM, rhs: RedvoxApiM_RedvoxPacketM) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._api != rhs_storage._api {return false}
        if _storage._subApi != rhs_storage._subApi {return false}
        if _storage._stationInformation != rhs_storage._stationInformation {return false}
        if _storage._timingInformation != rhs_storage._timingInformation {return false}
        if _storage._sensors != rhs_storage._sensors {return false}
        if _storage._eventStreams != rhs_storage._eventStreams {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_RedvoxPacketM.Unit: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "METERS_PER_SECOND_SQUARED"),
    2: .same(proto: "KILOPASCAL"),
    3: .same(proto: "RADIANS_PER_SECOND"),
    4: .same(proto: "DECIMAL_DEGREES"),
    5: .same(proto: "METERS"),
    6: .same(proto: "METERS_PER_SECOND"),
    7: .same(proto: "MICROTESLA"),
    8: .same(proto: "LSB_PLUS_MINUS_COUNTS"),
    9: .same(proto: "MICROSECONDS_SINCE_UNIX_EPOCH"),
    10: .same(proto: "DECIBEL"),
    11: .same(proto: "DEGREES_CELSIUS"),
    12: .same(proto: "BYTE"),
    13: .same(proto: "PERCENTAGE"),
    14: .same(proto: "RADIANS"),
    15: .same(proto: "MICROAMPERES"),
    16: .same(proto: "CENTIMETERS"),
    17: .same(proto: "NORMALIZED_COUNTS"),
    18: .same(proto: "LUX"),
    19: .same(proto: "UNITLESS"),
    20: .same(proto: "PCM"),
  ]
}

extension RedvoxApiM_RedvoxPacketM.StationInformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RedvoxApiM_RedvoxPacketM.protoMessageName + ".StationInformation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "uuid"),
    3: .same(proto: "description"),
    4: .standard(proto: "auth_id"),
    5: .same(proto: "make"),
    6: .same(proto: "model"),
    7: .same(proto: "os"),
    8: .standard(proto: "os_version"),
    9: .standard(proto: "app_version"),
    10: .standard(proto: "is_private"),
    11: .standard(proto: "app_settings"),
    12: .standard(proto: "station_metrics"),
    13: .standard(proto: "service_urls"),
    14: .same(proto: "metadata"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _uuid: String = String()
    var _description_p: String = String()
    var _authID: String = String()
    var _make: String = String()
    var _model: String = String()
    var _os: RedvoxApiM_RedvoxPacketM.StationInformation.OsType = .unknownOs
    var _osVersion: String = String()
    var _appVersion: String = String()
    var _isPrivate: Bool = false
    var _appSettings: RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings? = nil
    var _stationMetrics: RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics? = nil
    var _serviceUrls: RedvoxApiM_RedvoxPacketM.StationInformation.ServiceUrls? = nil
    var _metadata: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _uuid = source._uuid
      _description_p = source._description_p
      _authID = source._authID
      _make = source._make
      _model = source._model
      _os = source._os
      _osVersion = source._osVersion
      _appVersion = source._appVersion
      _isPrivate = source._isPrivate
      _appSettings = source._appSettings
      _stationMetrics = source._stationMetrics
      _serviceUrls = source._serviceUrls
      _metadata = source._metadata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._uuid) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._authID) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._make) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._model) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._os) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._osVersion) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._appVersion) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._isPrivate) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._appSettings) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._stationMetrics) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._serviceUrls) }()
        case 14: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._metadata) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._uuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uuid, fieldNumber: 2)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 3)
      }
      if !_storage._authID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._authID, fieldNumber: 4)
      }
      if !_storage._make.isEmpty {
        try visitor.visitSingularStringField(value: _storage._make, fieldNumber: 5)
      }
      if !_storage._model.isEmpty {
        try visitor.visitSingularStringField(value: _storage._model, fieldNumber: 6)
      }
      if _storage._os != .unknownOs {
        try visitor.visitSingularEnumField(value: _storage._os, fieldNumber: 7)
      }
      if !_storage._osVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._osVersion, fieldNumber: 8)
      }
      if !_storage._appVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appVersion, fieldNumber: 9)
      }
      if _storage._isPrivate != false {
        try visitor.visitSingularBoolField(value: _storage._isPrivate, fieldNumber: 10)
      }
      if let v = _storage._appSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._stationMetrics {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._serviceUrls {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._metadata, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_RedvoxPacketM.StationInformation, rhs: RedvoxApiM_RedvoxPacketM.StationInformation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._authID != rhs_storage._authID {return false}
        if _storage._make != rhs_storage._make {return false}
        if _storage._model != rhs_storage._model {return false}
        if _storage._os != rhs_storage._os {return false}
        if _storage._osVersion != rhs_storage._osVersion {return false}
        if _storage._appVersion != rhs_storage._appVersion {return false}
        if _storage._isPrivate != rhs_storage._isPrivate {return false}
        if _storage._appSettings != rhs_storage._appSettings {return false}
        if _storage._stationMetrics != rhs_storage._stationMetrics {return false}
        if _storage._serviceUrls != rhs_storage._serviceUrls {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_RedvoxPacketM.StationInformation.OsType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_OS"),
    1: .same(proto: "ANDROID"),
    2: .same(proto: "IOS"),
    3: .same(proto: "OSX"),
    4: .same(proto: "LINUX"),
    5: .same(proto: "WINDOWS"),
  ]
}

extension RedvoxApiM_RedvoxPacketM.StationInformation.ServiceUrls: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RedvoxApiM_RedvoxPacketM.StationInformation.protoMessageName + ".ServiceUrls"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auth_server"),
    2: .standard(proto: "synch_server"),
    3: .standard(proto: "acquisition_server"),
    4: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authServer) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.synchServer) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.acquisitionServer) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authServer.isEmpty {
      try visitor.visitSingularStringField(value: self.authServer, fieldNumber: 1)
    }
    if !self.synchServer.isEmpty {
      try visitor.visitSingularStringField(value: self.synchServer, fieldNumber: 2)
    }
    if !self.acquisitionServer.isEmpty {
      try visitor.visitSingularStringField(value: self.acquisitionServer, fieldNumber: 3)
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_RedvoxPacketM.StationInformation.ServiceUrls, rhs: RedvoxApiM_RedvoxPacketM.StationInformation.ServiceUrls) -> Bool {
    if lhs.authServer != rhs.authServer {return false}
    if lhs.synchServer != rhs.synchServer {return false}
    if lhs.acquisitionServer != rhs.acquisitionServer {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RedvoxApiM_RedvoxPacketM.StationInformation.protoMessageName + ".StationMetrics"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamps"),
    2: .standard(proto: "network_type"),
    3: .standard(proto: "cell_service_state"),
    4: .standard(proto: "network_strength"),
    5: .same(proto: "temperature"),
    6: .same(proto: "battery"),
    7: .standard(proto: "battery_current"),
    8: .standard(proto: "available_ram"),
    9: .standard(proto: "available_disk"),
    10: .standard(proto: "cpu_utilization"),
    11: .standard(proto: "power_state"),
    12: .standard(proto: "wifi_wake_lock"),
    13: .same(proto: "metadata"),
  ]

  fileprivate class _StorageClass {
    var _timestamps: RedvoxApiM_RedvoxPacketM.TimingPayload? = nil
    var _networkType: [RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics.NetworkType] = []
    var _cellServiceState: [RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics.CellServiceState] = []
    var _networkStrength: RedvoxApiM_RedvoxPacketM.SamplePayload? = nil
    var _temperature: RedvoxApiM_RedvoxPacketM.SamplePayload? = nil
    var _battery: RedvoxApiM_RedvoxPacketM.SamplePayload? = nil
    var _batteryCurrent: RedvoxApiM_RedvoxPacketM.SamplePayload? = nil
    var _availableRam: RedvoxApiM_RedvoxPacketM.SamplePayload? = nil
    var _availableDisk: RedvoxApiM_RedvoxPacketM.SamplePayload? = nil
    var _cpuUtilization: RedvoxApiM_RedvoxPacketM.SamplePayload? = nil
    var _powerState: [RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics.PowerState] = []
    var _wifiWakeLock: [RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics.WifiWakeLock] = []
    var _metadata: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _timestamps = source._timestamps
      _networkType = source._networkType
      _cellServiceState = source._cellServiceState
      _networkStrength = source._networkStrength
      _temperature = source._temperature
      _battery = source._battery
      _batteryCurrent = source._batteryCurrent
      _availableRam = source._availableRam
      _availableDisk = source._availableDisk
      _cpuUtilization = source._cpuUtilization
      _powerState = source._powerState
      _wifiWakeLock = source._wifiWakeLock
      _metadata = source._metadata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._timestamps) }()
        case 2: try { try decoder.decodeRepeatedEnumField(value: &_storage._networkType) }()
        case 3: try { try decoder.decodeRepeatedEnumField(value: &_storage._cellServiceState) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._networkStrength) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._temperature) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._battery) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._batteryCurrent) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._availableRam) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._availableDisk) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._cpuUtilization) }()
        case 11: try { try decoder.decodeRepeatedEnumField(value: &_storage._powerState) }()
        case 12: try { try decoder.decodeRepeatedEnumField(value: &_storage._wifiWakeLock) }()
        case 13: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._metadata) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._timestamps {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._networkType.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._networkType, fieldNumber: 2)
      }
      if !_storage._cellServiceState.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._cellServiceState, fieldNumber: 3)
      }
      if let v = _storage._networkStrength {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._temperature {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._battery {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._batteryCurrent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._availableRam {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._availableDisk {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._cpuUtilization {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if !_storage._powerState.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._powerState, fieldNumber: 11)
      }
      if !_storage._wifiWakeLock.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._wifiWakeLock, fieldNumber: 12)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._metadata, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics, rhs: RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._timestamps != rhs_storage._timestamps {return false}
        if _storage._networkType != rhs_storage._networkType {return false}
        if _storage._cellServiceState != rhs_storage._cellServiceState {return false}
        if _storage._networkStrength != rhs_storage._networkStrength {return false}
        if _storage._temperature != rhs_storage._temperature {return false}
        if _storage._battery != rhs_storage._battery {return false}
        if _storage._batteryCurrent != rhs_storage._batteryCurrent {return false}
        if _storage._availableRam != rhs_storage._availableRam {return false}
        if _storage._availableDisk != rhs_storage._availableDisk {return false}
        if _storage._cpuUtilization != rhs_storage._cpuUtilization {return false}
        if _storage._powerState != rhs_storage._powerState {return false}
        if _storage._wifiWakeLock != rhs_storage._wifiWakeLock {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics.NetworkType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_NETWORK"),
    1: .same(proto: "NO_NETWORK"),
    2: .same(proto: "WIFI"),
    3: .same(proto: "CELLULAR"),
    4: .same(proto: "WIRED"),
  ]
}

extension RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics.WifiWakeLock: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "HIGH_PERF"),
    2: .same(proto: "LOW_LATENCY"),
    3: .same(proto: "OTHER"),
  ]
}

extension RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics.CellServiceState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "EMERGENCY"),
    2: .same(proto: "NOMINAL"),
    3: .same(proto: "OUT_OF_SERVICE"),
    4: .same(proto: "POWER_OFF"),
  ]
}

extension RedvoxApiM_RedvoxPacketM.StationInformation.StationMetrics.PowerState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_POWER_STATE"),
    1: .same(proto: "UNPLUGGED"),
    2: .same(proto: "CHARGING"),
    3: .same(proto: "CHARGED"),
  ]
}

extension RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RedvoxApiM_RedvoxPacketM.StationInformation.protoMessageName + ".AppSettings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audio_sampling_rate"),
    2: .standard(proto: "samples_per_window"),
    3: .standard(proto: "audio_source_tuning"),
    4: .standard(proto: "additional_input_sensors"),
    5: .standard(proto: "automatically_record"),
    6: .standard(proto: "launch_at_power_up"),
    7: .standard(proto: "station_id"),
    8: .standard(proto: "station_description"),
    9: .standard(proto: "push_to_server"),
    10: .standard(proto: "publish_data_as_private"),
    11: .standard(proto: "scramble_audio_data"),
    12: .standard(proto: "provide_backfill"),
    13: .standard(proto: "remove_sensor_dc_offset"),
    14: .standard(proto: "fft_overlap"),
    15: .standard(proto: "use_custom_time_sync_server"),
    16: .standard(proto: "time_sync_server_url"),
    17: .standard(proto: "use_custom_data_server"),
    18: .standard(proto: "data_server_url"),
    19: .standard(proto: "use_custom_auth_server"),
    20: .standard(proto: "auth_server_url"),
    21: .standard(proto: "auto_delete_data_files"),
    22: .standard(proto: "storage_space_allowance"),
    23: .standard(proto: "use_sd_card_for_data_storage"),
    24: .standard(proto: "use_location_services"),
    25: .standard(proto: "use_latitude"),
    26: .standard(proto: "use_longitude"),
    27: .standard(proto: "use_altitude"),
    28: .same(proto: "metadata"),
  ]

  fileprivate class _StorageClass {
    var _audioSamplingRate: RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings.AudioSamplingRate = .unknownSamplingRate
    var _samplesPerWindow: Float = 0
    var _audioSourceTuning: RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings.AudioSourceTuning = .unknownTuning
    var _additionalInputSensors: [RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings.InputSensor] = []
    var _automaticallyRecord: Bool = false
    var _launchAtPowerUp: Bool = false
    var _stationID: String = String()
    var _stationDescription: String = String()
    var _pushToServer: Bool = false
    var _publishDataAsPrivate: Bool = false
    var _scrambleAudioData: Bool = false
    var _provideBackfill: Bool = false
    var _removeSensorDcOffset: Bool = false
    var _fftOverlap: RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings.FftOverlap = .unknown
    var _useCustomTimeSyncServer: Bool = false
    var _timeSyncServerURL: String = String()
    var _useCustomDataServer: Bool = false
    var _dataServerURL: String = String()
    var _useCustomAuthServer: Bool = false
    var _authServerURL: String = String()
    var _autoDeleteDataFiles: Bool = false
    var _storageSpaceAllowance: Float = 0
    var _useSdCardForDataStorage: Bool = false
    var _useLocationServices: Bool = false
    var _useLatitude: Double = 0
    var _useLongitude: Double = 0
    var _useAltitude: Float = 0
    var _metadata: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _audioSamplingRate = source._audioSamplingRate
      _samplesPerWindow = source._samplesPerWindow
      _audioSourceTuning = source._audioSourceTuning
      _additionalInputSensors = source._additionalInputSensors
      _automaticallyRecord = source._automaticallyRecord
      _launchAtPowerUp = source._launchAtPowerUp
      _stationID = source._stationID
      _stationDescription = source._stationDescription
      _pushToServer = source._pushToServer
      _publishDataAsPrivate = source._publishDataAsPrivate
      _scrambleAudioData = source._scrambleAudioData
      _provideBackfill = source._provideBackfill
      _removeSensorDcOffset = source._removeSensorDcOffset
      _fftOverlap = source._fftOverlap
      _useCustomTimeSyncServer = source._useCustomTimeSyncServer
      _timeSyncServerURL = source._timeSyncServerURL
      _useCustomDataServer = source._useCustomDataServer
      _dataServerURL = source._dataServerURL
      _useCustomAuthServer = source._useCustomAuthServer
      _authServerURL = source._authServerURL
      _autoDeleteDataFiles = source._autoDeleteDataFiles
      _storageSpaceAllowance = source._storageSpaceAllowance
      _useSdCardForDataStorage = source._useSdCardForDataStorage
      _useLocationServices = source._useLocationServices
      _useLatitude = source._useLatitude
      _useLongitude = source._useLongitude
      _useAltitude = source._useAltitude
      _metadata = source._metadata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._audioSamplingRate) }()
        case 2: try { try decoder.decodeSingularFloatField(value: &_storage._samplesPerWindow) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._audioSourceTuning) }()
        case 4: try { try decoder.decodeRepeatedEnumField(value: &_storage._additionalInputSensors) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._automaticallyRecord) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._launchAtPowerUp) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._stationID) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._stationDescription) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._pushToServer) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._publishDataAsPrivate) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._scrambleAudioData) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._provideBackfill) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._removeSensorDcOffset) }()
        case 14: try { try decoder.decodeSingularEnumField(value: &_storage._fftOverlap) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._useCustomTimeSyncServer) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._timeSyncServerURL) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._useCustomDataServer) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._dataServerURL) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._useCustomAuthServer) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._authServerURL) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._autoDeleteDataFiles) }()
        case 22: try { try decoder.decodeSingularFloatField(value: &_storage._storageSpaceAllowance) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._useSdCardForDataStorage) }()
        case 24: try { try decoder.decodeSingularBoolField(value: &_storage._useLocationServices) }()
        case 25: try { try decoder.decodeSingularDoubleField(value: &_storage._useLatitude) }()
        case 26: try { try decoder.decodeSingularDoubleField(value: &_storage._useLongitude) }()
        case 27: try { try decoder.decodeSingularFloatField(value: &_storage._useAltitude) }()
        case 28: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._metadata) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._audioSamplingRate != .unknownSamplingRate {
        try visitor.visitSingularEnumField(value: _storage._audioSamplingRate, fieldNumber: 1)
      }
      if _storage._samplesPerWindow != 0 {
        try visitor.visitSingularFloatField(value: _storage._samplesPerWindow, fieldNumber: 2)
      }
      if _storage._audioSourceTuning != .unknownTuning {
        try visitor.visitSingularEnumField(value: _storage._audioSourceTuning, fieldNumber: 3)
      }
      if !_storage._additionalInputSensors.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._additionalInputSensors, fieldNumber: 4)
      }
      if _storage._automaticallyRecord != false {
        try visitor.visitSingularBoolField(value: _storage._automaticallyRecord, fieldNumber: 5)
      }
      if _storage._launchAtPowerUp != false {
        try visitor.visitSingularBoolField(value: _storage._launchAtPowerUp, fieldNumber: 6)
      }
      if !_storage._stationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stationID, fieldNumber: 7)
      }
      if !_storage._stationDescription.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stationDescription, fieldNumber: 8)
      }
      if _storage._pushToServer != false {
        try visitor.visitSingularBoolField(value: _storage._pushToServer, fieldNumber: 9)
      }
      if _storage._publishDataAsPrivate != false {
        try visitor.visitSingularBoolField(value: _storage._publishDataAsPrivate, fieldNumber: 10)
      }
      if _storage._scrambleAudioData != false {
        try visitor.visitSingularBoolField(value: _storage._scrambleAudioData, fieldNumber: 11)
      }
      if _storage._provideBackfill != false {
        try visitor.visitSingularBoolField(value: _storage._provideBackfill, fieldNumber: 12)
      }
      if _storage._removeSensorDcOffset != false {
        try visitor.visitSingularBoolField(value: _storage._removeSensorDcOffset, fieldNumber: 13)
      }
      if _storage._fftOverlap != .unknown {
        try visitor.visitSingularEnumField(value: _storage._fftOverlap, fieldNumber: 14)
      }
      if _storage._useCustomTimeSyncServer != false {
        try visitor.visitSingularBoolField(value: _storage._useCustomTimeSyncServer, fieldNumber: 15)
      }
      if !_storage._timeSyncServerURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._timeSyncServerURL, fieldNumber: 16)
      }
      if _storage._useCustomDataServer != false {
        try visitor.visitSingularBoolField(value: _storage._useCustomDataServer, fieldNumber: 17)
      }
      if !_storage._dataServerURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._dataServerURL, fieldNumber: 18)
      }
      if _storage._useCustomAuthServer != false {
        try visitor.visitSingularBoolField(value: _storage._useCustomAuthServer, fieldNumber: 19)
      }
      if !_storage._authServerURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._authServerURL, fieldNumber: 20)
      }
      if _storage._autoDeleteDataFiles != false {
        try visitor.visitSingularBoolField(value: _storage._autoDeleteDataFiles, fieldNumber: 21)
      }
      if _storage._storageSpaceAllowance != 0 {
        try visitor.visitSingularFloatField(value: _storage._storageSpaceAllowance, fieldNumber: 22)
      }
      if _storage._useSdCardForDataStorage != false {
        try visitor.visitSingularBoolField(value: _storage._useSdCardForDataStorage, fieldNumber: 23)
      }
      if _storage._useLocationServices != false {
        try visitor.visitSingularBoolField(value: _storage._useLocationServices, fieldNumber: 24)
      }
      if _storage._useLatitude != 0 {
        try visitor.visitSingularDoubleField(value: _storage._useLatitude, fieldNumber: 25)
      }
      if _storage._useLongitude != 0 {
        try visitor.visitSingularDoubleField(value: _storage._useLongitude, fieldNumber: 26)
      }
      if _storage._useAltitude != 0 {
        try visitor.visitSingularFloatField(value: _storage._useAltitude, fieldNumber: 27)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._metadata, fieldNumber: 28)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings, rhs: RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._audioSamplingRate != rhs_storage._audioSamplingRate {return false}
        if _storage._samplesPerWindow != rhs_storage._samplesPerWindow {return false}
        if _storage._audioSourceTuning != rhs_storage._audioSourceTuning {return false}
        if _storage._additionalInputSensors != rhs_storage._additionalInputSensors {return false}
        if _storage._automaticallyRecord != rhs_storage._automaticallyRecord {return false}
        if _storage._launchAtPowerUp != rhs_storage._launchAtPowerUp {return false}
        if _storage._stationID != rhs_storage._stationID {return false}
        if _storage._stationDescription != rhs_storage._stationDescription {return false}
        if _storage._pushToServer != rhs_storage._pushToServer {return false}
        if _storage._publishDataAsPrivate != rhs_storage._publishDataAsPrivate {return false}
        if _storage._scrambleAudioData != rhs_storage._scrambleAudioData {return false}
        if _storage._provideBackfill != rhs_storage._provideBackfill {return false}
        if _storage._removeSensorDcOffset != rhs_storage._removeSensorDcOffset {return false}
        if _storage._fftOverlap != rhs_storage._fftOverlap {return false}
        if _storage._useCustomTimeSyncServer != rhs_storage._useCustomTimeSyncServer {return false}
        if _storage._timeSyncServerURL != rhs_storage._timeSyncServerURL {return false}
        if _storage._useCustomDataServer != rhs_storage._useCustomDataServer {return false}
        if _storage._dataServerURL != rhs_storage._dataServerURL {return false}
        if _storage._useCustomAuthServer != rhs_storage._useCustomAuthServer {return false}
        if _storage._authServerURL != rhs_storage._authServerURL {return false}
        if _storage._autoDeleteDataFiles != rhs_storage._autoDeleteDataFiles {return false}
        if _storage._storageSpaceAllowance != rhs_storage._storageSpaceAllowance {return false}
        if _storage._useSdCardForDataStorage != rhs_storage._useSdCardForDataStorage {return false}
        if _storage._useLocationServices != rhs_storage._useLocationServices {return false}
        if _storage._useLatitude != rhs_storage._useLatitude {return false}
        if _storage._useLongitude != rhs_storage._useLongitude {return false}
        if _storage._useAltitude != rhs_storage._useAltitude {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings.FftOverlap: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "PERCENT_25"),
    2: .same(proto: "PERCENT_50"),
    3: .same(proto: "PERCENT_75"),
  ]
}

extension RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings.AudioSamplingRate: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_SAMPLING_RATE"),
    1: .same(proto: "HZ_80"),
    2: .same(proto: "HZ_800"),
    3: .same(proto: "HZ_8000"),
    4: .same(proto: "HZ_16000"),
    5: .same(proto: "HZ_48000"),
  ]
}

extension RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings.AudioSourceTuning: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_TUNING"),
    1: .same(proto: "INFRASOUND_TUNING"),
    2: .same(proto: "LOW_AUDIO_TUNING"),
    3: .same(proto: "AUDIO_TUNING"),
  ]
}

extension RedvoxApiM_RedvoxPacketM.StationInformation.AppSettings.InputSensor: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_SENSOR"),
    1: .same(proto: "ACCELEROMETER"),
    2: .same(proto: "AMBIENT_TEMPERATURE"),
    3: .same(proto: "AUDIO"),
    4: .same(proto: "COMPRESSED_AUDIO"),
    5: .same(proto: "GRAVITY"),
    6: .same(proto: "GYROSCOPE"),
    7: .same(proto: "IMAGE"),
    8: .same(proto: "LIGHT"),
    9: .same(proto: "LINEAR_ACCELERATION"),
    10: .same(proto: "LOCATION"),
    11: .same(proto: "MAGNETOMETER"),
    12: .same(proto: "ORIENTATION"),
    13: .same(proto: "PRESSURE"),
    14: .same(proto: "PROXIMITY"),
    15: .same(proto: "RELATIVE_HUMIDITY"),
    16: .same(proto: "ROTATION_VECTOR"),
  ]
}

extension RedvoxApiM_RedvoxPacketM.TimingInformation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RedvoxApiM_RedvoxPacketM.protoMessageName + ".TimingInformation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "packet_start_os_timestamp"),
    2: .standard(proto: "packet_start_mach_timestamp"),
    3: .standard(proto: "packet_end_os_timestamp"),
    4: .standard(proto: "packet_end_mach_timestamp"),
    5: .standard(proto: "server_acquisition_arrival_timestamp"),
    6: .standard(proto: "app_start_mach_timestamp"),
    7: .standard(proto: "synch_exchanges"),
    8: .standard(proto: "best_latency"),
    9: .standard(proto: "best_offset"),
    10: .same(proto: "score"),
    11: .standard(proto: "score_method"),
    12: .same(proto: "unit"),
    13: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.packetStartOsTimestamp) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.packetStartMachTimestamp) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.packetEndOsTimestamp) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.packetEndMachTimestamp) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.serverAcquisitionArrivalTimestamp) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.appStartMachTimestamp) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.synchExchanges) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self.bestLatency) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self.bestOffset) }()
      case 10: try { try decoder.decodeSingularFloatField(value: &self.score) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.scoreMethod) }()
      case 12: try { try decoder.decodeSingularEnumField(value: &self.unit) }()
      case 13: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.packetStartOsTimestamp != 0 {
      try visitor.visitSingularDoubleField(value: self.packetStartOsTimestamp, fieldNumber: 1)
    }
    if self.packetStartMachTimestamp != 0 {
      try visitor.visitSingularDoubleField(value: self.packetStartMachTimestamp, fieldNumber: 2)
    }
    if self.packetEndOsTimestamp != 0 {
      try visitor.visitSingularDoubleField(value: self.packetEndOsTimestamp, fieldNumber: 3)
    }
    if self.packetEndMachTimestamp != 0 {
      try visitor.visitSingularDoubleField(value: self.packetEndMachTimestamp, fieldNumber: 4)
    }
    if self.serverAcquisitionArrivalTimestamp != 0 {
      try visitor.visitSingularDoubleField(value: self.serverAcquisitionArrivalTimestamp, fieldNumber: 5)
    }
    if self.appStartMachTimestamp != 0 {
      try visitor.visitSingularDoubleField(value: self.appStartMachTimestamp, fieldNumber: 6)
    }
    if !self.synchExchanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.synchExchanges, fieldNumber: 7)
    }
    if self.bestLatency != 0 {
      try visitor.visitSingularFloatField(value: self.bestLatency, fieldNumber: 8)
    }
    if self.bestOffset != 0 {
      try visitor.visitSingularFloatField(value: self.bestOffset, fieldNumber: 9)
    }
    if self.score != 0 {
      try visitor.visitSingularFloatField(value: self.score, fieldNumber: 10)
    }
    if self.scoreMethod != .unknown {
      try visitor.visitSingularEnumField(value: self.scoreMethod, fieldNumber: 11)
    }
    if self.unit != .unknown {
      try visitor.visitSingularEnumField(value: self.unit, fieldNumber: 12)
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_RedvoxPacketM.TimingInformation, rhs: RedvoxApiM_RedvoxPacketM.TimingInformation) -> Bool {
    if lhs.packetStartOsTimestamp != rhs.packetStartOsTimestamp {return false}
    if lhs.packetStartMachTimestamp != rhs.packetStartMachTimestamp {return false}
    if lhs.packetEndOsTimestamp != rhs.packetEndOsTimestamp {return false}
    if lhs.packetEndMachTimestamp != rhs.packetEndMachTimestamp {return false}
    if lhs.serverAcquisitionArrivalTimestamp != rhs.serverAcquisitionArrivalTimestamp {return false}
    if lhs.appStartMachTimestamp != rhs.appStartMachTimestamp {return false}
    if lhs.synchExchanges != rhs.synchExchanges {return false}
    if lhs.bestLatency != rhs.bestLatency {return false}
    if lhs.bestOffset != rhs.bestOffset {return false}
    if lhs.score != rhs.score {return false}
    if lhs.scoreMethod != rhs.scoreMethod {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_RedvoxPacketM.TimingInformation.TimingScoreMethod: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
  ]
}

extension RedvoxApiM_RedvoxPacketM.TimingInformation.SynchExchange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RedvoxApiM_RedvoxPacketM.TimingInformation.protoMessageName + ".SynchExchange"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "a1"),
    2: .same(proto: "a2"),
    3: .same(proto: "a3"),
    4: .same(proto: "b1"),
    5: .same(proto: "b2"),
    6: .same(proto: "b3"),
    7: .same(proto: "unit"),
    8: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.a1) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.a2) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.a3) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.b1) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.b2) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.b3) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.unit) }()
      case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.a1 != 0 {
      try visitor.visitSingularDoubleField(value: self.a1, fieldNumber: 1)
    }
    if self.a2 != 0 {
      try visitor.visitSingularDoubleField(value: self.a2, fieldNumber: 2)
    }
    if self.a3 != 0 {
      try visitor.visitSingularDoubleField(value: self.a3, fieldNumber: 3)
    }
    if self.b1 != 0 {
      try visitor.visitSingularDoubleField(value: self.b1, fieldNumber: 4)
    }
    if self.b2 != 0 {
      try visitor.visitSingularDoubleField(value: self.b2, fieldNumber: 5)
    }
    if self.b3 != 0 {
      try visitor.visitSingularDoubleField(value: self.b3, fieldNumber: 6)
    }
    if self.unit != .unknown {
      try visitor.visitSingularEnumField(value: self.unit, fieldNumber: 7)
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_RedvoxPacketM.TimingInformation.SynchExchange, rhs: RedvoxApiM_RedvoxPacketM.TimingInformation.SynchExchange) -> Bool {
    if lhs.a1 != rhs.a1 {return false}
    if lhs.a2 != rhs.a2 {return false}
    if lhs.a3 != rhs.a3 {return false}
    if lhs.b1 != rhs.b1 {return false}
    if lhs.b2 != rhs.b2 {return false}
    if lhs.b3 != rhs.b3 {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_RedvoxPacketM.Sensors: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RedvoxApiM_RedvoxPacketM.protoMessageName + ".Sensors"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accelerometer"),
    2: .standard(proto: "ambient_temperature"),
    3: .same(proto: "audio"),
    4: .standard(proto: "compressed_audio"),
    5: .same(proto: "gravity"),
    6: .same(proto: "gyroscope"),
    7: .same(proto: "image"),
    8: .same(proto: "light"),
    9: .standard(proto: "linear_acceleration"),
    10: .same(proto: "location"),
    11: .same(proto: "magnetometer"),
    12: .same(proto: "orientation"),
    13: .same(proto: "pressure"),
    14: .same(proto: "proximity"),
    15: .standard(proto: "relative_humidity"),
    16: .standard(proto: "rotation_vector"),
    17: .same(proto: "metadata"),
  ]

  fileprivate class _StorageClass {
    var _accelerometer: RedvoxApiM_RedvoxPacketM.Sensors.Xyz? = nil
    var _ambientTemperature: RedvoxApiM_RedvoxPacketM.Sensors.Single? = nil
    var _audio: RedvoxApiM_RedvoxPacketM.Sensors.Audio? = nil
    var _compressedAudio: RedvoxApiM_RedvoxPacketM.Sensors.CompressedAudio? = nil
    var _gravity: RedvoxApiM_RedvoxPacketM.Sensors.Xyz? = nil
    var _gyroscope: RedvoxApiM_RedvoxPacketM.Sensors.Xyz? = nil
    var _image: RedvoxApiM_RedvoxPacketM.Sensors.Image? = nil
    var _light: RedvoxApiM_RedvoxPacketM.Sensors.Single? = nil
    var _linearAcceleration: RedvoxApiM_RedvoxPacketM.Sensors.Xyz? = nil
    var _location: RedvoxApiM_RedvoxPacketM.Sensors.Location? = nil
    var _magnetometer: RedvoxApiM_RedvoxPacketM.Sensors.Xyz? = nil
    var _orientation: RedvoxApiM_RedvoxPacketM.Sensors.Xyz? = nil
    var _pressure: RedvoxApiM_RedvoxPacketM.Sensors.Single? = nil
    var _proximity: RedvoxApiM_RedvoxPacketM.Sensors.Single? = nil
    var _relativeHumidity: RedvoxApiM_RedvoxPacketM.Sensors.Single? = nil
    var _rotationVector: RedvoxApiM_RedvoxPacketM.Sensors.Xyz? = nil
    var _metadata: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _accelerometer = source._accelerometer
      _ambientTemperature = source._ambientTemperature
      _audio = source._audio
      _compressedAudio = source._compressedAudio
      _gravity = source._gravity
      _gyroscope = source._gyroscope
      _image = source._image
      _light = source._light
      _linearAcceleration = source._linearAcceleration
      _location = source._location
      _magnetometer = source._magnetometer
      _orientation = source._orientation
      _pressure = source._pressure
      _proximity = source._proximity
      _relativeHumidity = source._relativeHumidity
      _rotationVector = source._rotationVector
      _metadata = source._metadata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._accelerometer) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._ambientTemperature) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._audio) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._compressedAudio) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._gravity) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._gyroscope) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._image) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._light) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._linearAcceleration) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._location) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._magnetometer) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._orientation) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._pressure) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._proximity) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._relativeHumidity) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._rotationVector) }()
        case 17: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._metadata) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._accelerometer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._ambientTemperature {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._audio {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._compressedAudio {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._gravity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._gyroscope {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._image {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._light {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._linearAcceleration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._magnetometer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._orientation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._pressure {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._proximity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._relativeHumidity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._rotationVector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._metadata, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_RedvoxPacketM.Sensors, rhs: RedvoxApiM_RedvoxPacketM.Sensors) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._accelerometer != rhs_storage._accelerometer {return false}
        if _storage._ambientTemperature != rhs_storage._ambientTemperature {return false}
        if _storage._audio != rhs_storage._audio {return false}
        if _storage._compressedAudio != rhs_storage._compressedAudio {return false}
        if _storage._gravity != rhs_storage._gravity {return false}
        if _storage._gyroscope != rhs_storage._gyroscope {return false}
        if _storage._image != rhs_storage._image {return false}
        if _storage._light != rhs_storage._light {return false}
        if _storage._linearAcceleration != rhs_storage._linearAcceleration {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._magnetometer != rhs_storage._magnetometer {return false}
        if _storage._orientation != rhs_storage._orientation {return false}
        if _storage._pressure != rhs_storage._pressure {return false}
        if _storage._proximity != rhs_storage._proximity {return false}
        if _storage._relativeHumidity != rhs_storage._relativeHumidity {return false}
        if _storage._rotationVector != rhs_storage._rotationVector {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_RedvoxPacketM.Sensors.Audio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RedvoxApiM_RedvoxPacketM.Sensors.protoMessageName + ".Audio"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sensor_description"),
    2: .standard(proto: "first_sample_timestamp"),
    3: .standard(proto: "sample_rate"),
    4: .standard(proto: "bits_of_precision"),
    5: .standard(proto: "is_scrambled"),
    6: .same(proto: "encoding"),
    7: .same(proto: "samples"),
    8: .same(proto: "metadata"),
  ]

  fileprivate class _StorageClass {
    var _sensorDescription: String = String()
    var _firstSampleTimestamp: Double = 0
    var _sampleRate: Float = 0
    var _bitsOfPrecision: Float = 0
    var _isScrambled: Bool = false
    var _encoding: String = String()
    var _samples: RedvoxApiM_RedvoxPacketM.SamplePayload? = nil
    var _metadata: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sensorDescription = source._sensorDescription
      _firstSampleTimestamp = source._firstSampleTimestamp
      _sampleRate = source._sampleRate
      _bitsOfPrecision = source._bitsOfPrecision
      _isScrambled = source._isScrambled
      _encoding = source._encoding
      _samples = source._samples
      _metadata = source._metadata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._sensorDescription) }()
        case 2: try { try decoder.decodeSingularDoubleField(value: &_storage._firstSampleTimestamp) }()
        case 3: try { try decoder.decodeSingularFloatField(value: &_storage._sampleRate) }()
        case 4: try { try decoder.decodeSingularFloatField(value: &_storage._bitsOfPrecision) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._isScrambled) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._encoding) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._samples) }()
        case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._metadata) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._sensorDescription.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sensorDescription, fieldNumber: 1)
      }
      if _storage._firstSampleTimestamp != 0 {
        try visitor.visitSingularDoubleField(value: _storage._firstSampleTimestamp, fieldNumber: 2)
      }
      if _storage._sampleRate != 0 {
        try visitor.visitSingularFloatField(value: _storage._sampleRate, fieldNumber: 3)
      }
      if _storage._bitsOfPrecision != 0 {
        try visitor.visitSingularFloatField(value: _storage._bitsOfPrecision, fieldNumber: 4)
      }
      if _storage._isScrambled != false {
        try visitor.visitSingularBoolField(value: _storage._isScrambled, fieldNumber: 5)
      }
      if !_storage._encoding.isEmpty {
        try visitor.visitSingularStringField(value: _storage._encoding, fieldNumber: 6)
      }
      if let v = _storage._samples {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._metadata, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_RedvoxPacketM.Sensors.Audio, rhs: RedvoxApiM_RedvoxPacketM.Sensors.Audio) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sensorDescription != rhs_storage._sensorDescription {return false}
        if _storage._firstSampleTimestamp != rhs_storage._firstSampleTimestamp {return false}
        if _storage._sampleRate != rhs_storage._sampleRate {return false}
        if _storage._bitsOfPrecision != rhs_storage._bitsOfPrecision {return false}
        if _storage._isScrambled != rhs_storage._isScrambled {return false}
        if _storage._encoding != rhs_storage._encoding {return false}
        if _storage._samples != rhs_storage._samples {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_RedvoxPacketM.Sensors.CompressedAudio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RedvoxApiM_RedvoxPacketM.Sensors.protoMessageName + ".CompressedAudio"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sensor_description"),
    2: .standard(proto: "first_sample_timestamp"),
    3: .standard(proto: "sample_rate"),
    4: .standard(proto: "is_scrambled"),
    5: .standard(proto: "audio_bytes"),
    6: .standard(proto: "audio_codec"),
    7: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sensorDescription) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.firstSampleTimestamp) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.sampleRate) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isScrambled) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.audioBytes) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.audioCodec) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sensorDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.sensorDescription, fieldNumber: 1)
    }
    if self.firstSampleTimestamp != 0 {
      try visitor.visitSingularDoubleField(value: self.firstSampleTimestamp, fieldNumber: 2)
    }
    if self.sampleRate != 0 {
      try visitor.visitSingularFloatField(value: self.sampleRate, fieldNumber: 3)
    }
    if self.isScrambled != false {
      try visitor.visitSingularBoolField(value: self.isScrambled, fieldNumber: 4)
    }
    if !self.audioBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.audioBytes, fieldNumber: 5)
    }
    if self.audioCodec != .unknown {
      try visitor.visitSingularEnumField(value: self.audioCodec, fieldNumber: 6)
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_RedvoxPacketM.Sensors.CompressedAudio, rhs: RedvoxApiM_RedvoxPacketM.Sensors.CompressedAudio) -> Bool {
    if lhs.sensorDescription != rhs.sensorDescription {return false}
    if lhs.firstSampleTimestamp != rhs.firstSampleTimestamp {return false}
    if lhs.sampleRate != rhs.sampleRate {return false}
    if lhs.isScrambled != rhs.isScrambled {return false}
    if lhs.audioBytes != rhs.audioBytes {return false}
    if lhs.audioCodec != rhs.audioCodec {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_RedvoxPacketM.Sensors.CompressedAudio.AudioCodec: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "FLAC"),
  ]
}

extension RedvoxApiM_RedvoxPacketM.Sensors.Single: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RedvoxApiM_RedvoxPacketM.Sensors.protoMessageName + ".Single"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sensor_description"),
    2: .same(proto: "timestamps"),
    3: .same(proto: "samples"),
    4: .same(proto: "metadata"),
  ]

  fileprivate class _StorageClass {
    var _sensorDescription: String = String()
    var _timestamps: RedvoxApiM_RedvoxPacketM.TimingPayload? = nil
    var _samples: RedvoxApiM_RedvoxPacketM.SamplePayload? = nil
    var _metadata: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sensorDescription = source._sensorDescription
      _timestamps = source._timestamps
      _samples = source._samples
      _metadata = source._metadata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._sensorDescription) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._timestamps) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._samples) }()
        case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._metadata) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._sensorDescription.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sensorDescription, fieldNumber: 1)
      }
      if let v = _storage._timestamps {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._samples {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._metadata, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_RedvoxPacketM.Sensors.Single, rhs: RedvoxApiM_RedvoxPacketM.Sensors.Single) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sensorDescription != rhs_storage._sensorDescription {return false}
        if _storage._timestamps != rhs_storage._timestamps {return false}
        if _storage._samples != rhs_storage._samples {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_RedvoxPacketM.Sensors.Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RedvoxApiM_RedvoxPacketM.Sensors.protoMessageName + ".Location"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sensor_description"),
    2: .same(proto: "timestamps"),
    3: .standard(proto: "timestamps_gps"),
    4: .standard(proto: "latitude_samples"),
    5: .standard(proto: "longitude_samples"),
    6: .standard(proto: "altitude_samples"),
    7: .standard(proto: "speed_samples"),
    8: .standard(proto: "bearing_samples"),
    9: .standard(proto: "horizontal_accuracy_samples"),
    10: .standard(proto: "vertical_accuracy_samples"),
    11: .standard(proto: "speed_accuracy_samples"),
    12: .standard(proto: "bearing_accuracy_samples"),
    13: .standard(proto: "last_best_location"),
    14: .standard(proto: "overall_best_location"),
    15: .standard(proto: "location_permissions_granted"),
    16: .standard(proto: "location_services_requested"),
    17: .standard(proto: "location_services_enabled"),
    18: .standard(proto: "location_providers"),
    19: .same(proto: "metadata"),
  ]

  fileprivate class _StorageClass {
    var _sensorDescription: String = String()
    var _timestamps: RedvoxApiM_RedvoxPacketM.TimingPayload? = nil
    var _timestampsGps: RedvoxApiM_RedvoxPacketM.TimingPayload? = nil
    var _latitudeSamples: RedvoxApiM_RedvoxPacketM.DoubleSamplePayload? = nil
    var _longitudeSamples: RedvoxApiM_RedvoxPacketM.DoubleSamplePayload? = nil
    var _altitudeSamples: RedvoxApiM_RedvoxPacketM.SamplePayload? = nil
    var _speedSamples: RedvoxApiM_RedvoxPacketM.SamplePayload? = nil
    var _bearingSamples: RedvoxApiM_RedvoxPacketM.SamplePayload? = nil
    var _horizontalAccuracySamples: RedvoxApiM_RedvoxPacketM.SamplePayload? = nil
    var _verticalAccuracySamples: RedvoxApiM_RedvoxPacketM.SamplePayload? = nil
    var _speedAccuracySamples: RedvoxApiM_RedvoxPacketM.SamplePayload? = nil
    var _bearingAccuracySamples: RedvoxApiM_RedvoxPacketM.SamplePayload? = nil
    var _lastBestLocation: RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation? = nil
    var _overallBestLocation: RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation? = nil
    var _locationPermissionsGranted: Bool = false
    var _locationServicesRequested: Bool = false
    var _locationServicesEnabled: Bool = false
    var _locationProviders: [RedvoxApiM_RedvoxPacketM.Sensors.Location.LocationProvider] = []
    var _metadata: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sensorDescription = source._sensorDescription
      _timestamps = source._timestamps
      _timestampsGps = source._timestampsGps
      _latitudeSamples = source._latitudeSamples
      _longitudeSamples = source._longitudeSamples
      _altitudeSamples = source._altitudeSamples
      _speedSamples = source._speedSamples
      _bearingSamples = source._bearingSamples
      _horizontalAccuracySamples = source._horizontalAccuracySamples
      _verticalAccuracySamples = source._verticalAccuracySamples
      _speedAccuracySamples = source._speedAccuracySamples
      _bearingAccuracySamples = source._bearingAccuracySamples
      _lastBestLocation = source._lastBestLocation
      _overallBestLocation = source._overallBestLocation
      _locationPermissionsGranted = source._locationPermissionsGranted
      _locationServicesRequested = source._locationServicesRequested
      _locationServicesEnabled = source._locationServicesEnabled
      _locationProviders = source._locationProviders
      _metadata = source._metadata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._sensorDescription) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._timestamps) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._timestampsGps) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._latitudeSamples) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._longitudeSamples) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._altitudeSamples) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._speedSamples) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._bearingSamples) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._horizontalAccuracySamples) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._verticalAccuracySamples) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._speedAccuracySamples) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._bearingAccuracySamples) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._lastBestLocation) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._overallBestLocation) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._locationPermissionsGranted) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._locationServicesRequested) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._locationServicesEnabled) }()
        case 18: try { try decoder.decodeRepeatedEnumField(value: &_storage._locationProviders) }()
        case 19: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._metadata) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._sensorDescription.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sensorDescription, fieldNumber: 1)
      }
      if let v = _storage._timestamps {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._timestampsGps {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._latitudeSamples {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._longitudeSamples {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._altitudeSamples {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._speedSamples {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._bearingSamples {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._horizontalAccuracySamples {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._verticalAccuracySamples {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._speedAccuracySamples {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._bearingAccuracySamples {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._lastBestLocation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._overallBestLocation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if _storage._locationPermissionsGranted != false {
        try visitor.visitSingularBoolField(value: _storage._locationPermissionsGranted, fieldNumber: 15)
      }
      if _storage._locationServicesRequested != false {
        try visitor.visitSingularBoolField(value: _storage._locationServicesRequested, fieldNumber: 16)
      }
      if _storage._locationServicesEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._locationServicesEnabled, fieldNumber: 17)
      }
      if !_storage._locationProviders.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._locationProviders, fieldNumber: 18)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._metadata, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_RedvoxPacketM.Sensors.Location, rhs: RedvoxApiM_RedvoxPacketM.Sensors.Location) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sensorDescription != rhs_storage._sensorDescription {return false}
        if _storage._timestamps != rhs_storage._timestamps {return false}
        if _storage._timestampsGps != rhs_storage._timestampsGps {return false}
        if _storage._latitudeSamples != rhs_storage._latitudeSamples {return false}
        if _storage._longitudeSamples != rhs_storage._longitudeSamples {return false}
        if _storage._altitudeSamples != rhs_storage._altitudeSamples {return false}
        if _storage._speedSamples != rhs_storage._speedSamples {return false}
        if _storage._bearingSamples != rhs_storage._bearingSamples {return false}
        if _storage._horizontalAccuracySamples != rhs_storage._horizontalAccuracySamples {return false}
        if _storage._verticalAccuracySamples != rhs_storage._verticalAccuracySamples {return false}
        if _storage._speedAccuracySamples != rhs_storage._speedAccuracySamples {return false}
        if _storage._bearingAccuracySamples != rhs_storage._bearingAccuracySamples {return false}
        if _storage._lastBestLocation != rhs_storage._lastBestLocation {return false}
        if _storage._overallBestLocation != rhs_storage._overallBestLocation {return false}
        if _storage._locationPermissionsGranted != rhs_storage._locationPermissionsGranted {return false}
        if _storage._locationServicesRequested != rhs_storage._locationServicesRequested {return false}
        if _storage._locationServicesEnabled != rhs_storage._locationServicesEnabled {return false}
        if _storage._locationProviders != rhs_storage._locationProviders {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_RedvoxPacketM.Sensors.Location.LocationProvider: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "NONE"),
    2: .same(proto: "USER"),
    3: .same(proto: "GPS"),
    4: .same(proto: "NETWORK"),
  ]
}

extension RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RedvoxApiM_RedvoxPacketM.Sensors.Location.protoMessageName + ".BestLocation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "latitude_longitude_timestamp"),
    2: .standard(proto: "altitude_timestamp"),
    3: .standard(proto: "speed_timestamp"),
    4: .standard(proto: "bearing_timestamp"),
    5: .standard(proto: "latitude_longitude_unit"),
    6: .standard(proto: "altitude_unit"),
    7: .standard(proto: "speed_unit"),
    8: .standard(proto: "bearing_unit"),
    9: .standard(proto: "vertical_accuracy_unit"),
    10: .standard(proto: "horizontal_accuracy_unit"),
    11: .standard(proto: "speed_accuracy_unit"),
    12: .standard(proto: "bearing_accuracy_unit"),
    13: .same(proto: "latitude"),
    14: .same(proto: "longitude"),
    15: .same(proto: "altitude"),
    16: .same(proto: "speed"),
    17: .same(proto: "bearing"),
    18: .standard(proto: "vertical_accuracy"),
    19: .standard(proto: "horizontal_accuracy"),
    20: .standard(proto: "speed_accuracy"),
    21: .standard(proto: "bearing_accuracy"),
    22: .same(proto: "score"),
    23: .same(proto: "method"),
    24: .standard(proto: "location_provider"),
    25: .same(proto: "metadata"),
  ]

  fileprivate class _StorageClass {
    var _latitudeLongitudeTimestamp: RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation.BestTimestamp? = nil
    var _altitudeTimestamp: RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation.BestTimestamp? = nil
    var _speedTimestamp: RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation.BestTimestamp? = nil
    var _bearingTimestamp: RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation.BestTimestamp? = nil
    var _latitudeLongitudeUnit: RedvoxApiM_RedvoxPacketM.Unit = .unknown
    var _altitudeUnit: RedvoxApiM_RedvoxPacketM.Unit = .unknown
    var _speedUnit: RedvoxApiM_RedvoxPacketM.Unit = .unknown
    var _bearingUnit: RedvoxApiM_RedvoxPacketM.Unit = .unknown
    var _verticalAccuracyUnit: RedvoxApiM_RedvoxPacketM.Unit = .unknown
    var _horizontalAccuracyUnit: RedvoxApiM_RedvoxPacketM.Unit = .unknown
    var _speedAccuracyUnit: RedvoxApiM_RedvoxPacketM.Unit = .unknown
    var _bearingAccuracyUnit: RedvoxApiM_RedvoxPacketM.Unit = .unknown
    var _latitude: Double = 0
    var _longitude: Double = 0
    var _altitude: Float = 0
    var _speed: Float = 0
    var _bearing: Float = 0
    var _verticalAccuracy: Float = 0
    var _horizontalAccuracy: Float = 0
    var _speedAccuracy: Float = 0
    var _bearingAccuracy: Float = 0
    var _score: Float = 0
    var _method: RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation.LocationScoreMethod = .unknownMethod
    var _locationProvider: RedvoxApiM_RedvoxPacketM.Sensors.Location.LocationProvider = .unknown
    var _metadata: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _latitudeLongitudeTimestamp = source._latitudeLongitudeTimestamp
      _altitudeTimestamp = source._altitudeTimestamp
      _speedTimestamp = source._speedTimestamp
      _bearingTimestamp = source._bearingTimestamp
      _latitudeLongitudeUnit = source._latitudeLongitudeUnit
      _altitudeUnit = source._altitudeUnit
      _speedUnit = source._speedUnit
      _bearingUnit = source._bearingUnit
      _verticalAccuracyUnit = source._verticalAccuracyUnit
      _horizontalAccuracyUnit = source._horizontalAccuracyUnit
      _speedAccuracyUnit = source._speedAccuracyUnit
      _bearingAccuracyUnit = source._bearingAccuracyUnit
      _latitude = source._latitude
      _longitude = source._longitude
      _altitude = source._altitude
      _speed = source._speed
      _bearing = source._bearing
      _verticalAccuracy = source._verticalAccuracy
      _horizontalAccuracy = source._horizontalAccuracy
      _speedAccuracy = source._speedAccuracy
      _bearingAccuracy = source._bearingAccuracy
      _score = source._score
      _method = source._method
      _locationProvider = source._locationProvider
      _metadata = source._metadata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._latitudeLongitudeTimestamp) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._altitudeTimestamp) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._speedTimestamp) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._bearingTimestamp) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._latitudeLongitudeUnit) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._altitudeUnit) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._speedUnit) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._bearingUnit) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._verticalAccuracyUnit) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._horizontalAccuracyUnit) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._speedAccuracyUnit) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._bearingAccuracyUnit) }()
        case 13: try { try decoder.decodeSingularDoubleField(value: &_storage._latitude) }()
        case 14: try { try decoder.decodeSingularDoubleField(value: &_storage._longitude) }()
        case 15: try { try decoder.decodeSingularFloatField(value: &_storage._altitude) }()
        case 16: try { try decoder.decodeSingularFloatField(value: &_storage._speed) }()
        case 17: try { try decoder.decodeSingularFloatField(value: &_storage._bearing) }()
        case 18: try { try decoder.decodeSingularFloatField(value: &_storage._verticalAccuracy) }()
        case 19: try { try decoder.decodeSingularFloatField(value: &_storage._horizontalAccuracy) }()
        case 20: try { try decoder.decodeSingularFloatField(value: &_storage._speedAccuracy) }()
        case 21: try { try decoder.decodeSingularFloatField(value: &_storage._bearingAccuracy) }()
        case 22: try { try decoder.decodeSingularFloatField(value: &_storage._score) }()
        case 23: try { try decoder.decodeSingularEnumField(value: &_storage._method) }()
        case 24: try { try decoder.decodeSingularEnumField(value: &_storage._locationProvider) }()
        case 25: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._metadata) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._latitudeLongitudeTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._altitudeTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._speedTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._bearingTimestamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._latitudeLongitudeUnit != .unknown {
        try visitor.visitSingularEnumField(value: _storage._latitudeLongitudeUnit, fieldNumber: 5)
      }
      if _storage._altitudeUnit != .unknown {
        try visitor.visitSingularEnumField(value: _storage._altitudeUnit, fieldNumber: 6)
      }
      if _storage._speedUnit != .unknown {
        try visitor.visitSingularEnumField(value: _storage._speedUnit, fieldNumber: 7)
      }
      if _storage._bearingUnit != .unknown {
        try visitor.visitSingularEnumField(value: _storage._bearingUnit, fieldNumber: 8)
      }
      if _storage._verticalAccuracyUnit != .unknown {
        try visitor.visitSingularEnumField(value: _storage._verticalAccuracyUnit, fieldNumber: 9)
      }
      if _storage._horizontalAccuracyUnit != .unknown {
        try visitor.visitSingularEnumField(value: _storage._horizontalAccuracyUnit, fieldNumber: 10)
      }
      if _storage._speedAccuracyUnit != .unknown {
        try visitor.visitSingularEnumField(value: _storage._speedAccuracyUnit, fieldNumber: 11)
      }
      if _storage._bearingAccuracyUnit != .unknown {
        try visitor.visitSingularEnumField(value: _storage._bearingAccuracyUnit, fieldNumber: 12)
      }
      if _storage._latitude != 0 {
        try visitor.visitSingularDoubleField(value: _storage._latitude, fieldNumber: 13)
      }
      if _storage._longitude != 0 {
        try visitor.visitSingularDoubleField(value: _storage._longitude, fieldNumber: 14)
      }
      if _storage._altitude != 0 {
        try visitor.visitSingularFloatField(value: _storage._altitude, fieldNumber: 15)
      }
      if _storage._speed != 0 {
        try visitor.visitSingularFloatField(value: _storage._speed, fieldNumber: 16)
      }
      if _storage._bearing != 0 {
        try visitor.visitSingularFloatField(value: _storage._bearing, fieldNumber: 17)
      }
      if _storage._verticalAccuracy != 0 {
        try visitor.visitSingularFloatField(value: _storage._verticalAccuracy, fieldNumber: 18)
      }
      if _storage._horizontalAccuracy != 0 {
        try visitor.visitSingularFloatField(value: _storage._horizontalAccuracy, fieldNumber: 19)
      }
      if _storage._speedAccuracy != 0 {
        try visitor.visitSingularFloatField(value: _storage._speedAccuracy, fieldNumber: 20)
      }
      if _storage._bearingAccuracy != 0 {
        try visitor.visitSingularFloatField(value: _storage._bearingAccuracy, fieldNumber: 21)
      }
      if _storage._score != 0 {
        try visitor.visitSingularFloatField(value: _storage._score, fieldNumber: 22)
      }
      if _storage._method != .unknownMethod {
        try visitor.visitSingularEnumField(value: _storage._method, fieldNumber: 23)
      }
      if _storage._locationProvider != .unknown {
        try visitor.visitSingularEnumField(value: _storage._locationProvider, fieldNumber: 24)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._metadata, fieldNumber: 25)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation, rhs: RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._latitudeLongitudeTimestamp != rhs_storage._latitudeLongitudeTimestamp {return false}
        if _storage._altitudeTimestamp != rhs_storage._altitudeTimestamp {return false}
        if _storage._speedTimestamp != rhs_storage._speedTimestamp {return false}
        if _storage._bearingTimestamp != rhs_storage._bearingTimestamp {return false}
        if _storage._latitudeLongitudeUnit != rhs_storage._latitudeLongitudeUnit {return false}
        if _storage._altitudeUnit != rhs_storage._altitudeUnit {return false}
        if _storage._speedUnit != rhs_storage._speedUnit {return false}
        if _storage._bearingUnit != rhs_storage._bearingUnit {return false}
        if _storage._verticalAccuracyUnit != rhs_storage._verticalAccuracyUnit {return false}
        if _storage._horizontalAccuracyUnit != rhs_storage._horizontalAccuracyUnit {return false}
        if _storage._speedAccuracyUnit != rhs_storage._speedAccuracyUnit {return false}
        if _storage._bearingAccuracyUnit != rhs_storage._bearingAccuracyUnit {return false}
        if _storage._latitude != rhs_storage._latitude {return false}
        if _storage._longitude != rhs_storage._longitude {return false}
        if _storage._altitude != rhs_storage._altitude {return false}
        if _storage._speed != rhs_storage._speed {return false}
        if _storage._bearing != rhs_storage._bearing {return false}
        if _storage._verticalAccuracy != rhs_storage._verticalAccuracy {return false}
        if _storage._horizontalAccuracy != rhs_storage._horizontalAccuracy {return false}
        if _storage._speedAccuracy != rhs_storage._speedAccuracy {return false}
        if _storage._bearingAccuracy != rhs_storage._bearingAccuracy {return false}
        if _storage._score != rhs_storage._score {return false}
        if _storage._method != rhs_storage._method {return false}
        if _storage._locationProvider != rhs_storage._locationProvider {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation.LocationScoreMethod: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_METHOD"),
  ]
}

extension RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation.BestTimestamp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation.protoMessageName + ".BestTimestamp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unit"),
    2: .same(proto: "mach"),
    3: .same(proto: "gps"),
    4: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.unit) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.mach) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.gps) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.unit != .unknown {
      try visitor.visitSingularEnumField(value: self.unit, fieldNumber: 1)
    }
    if self.mach != 0 {
      try visitor.visitSingularDoubleField(value: self.mach, fieldNumber: 2)
    }
    if self.gps != 0 {
      try visitor.visitSingularDoubleField(value: self.gps, fieldNumber: 3)
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation.BestTimestamp, rhs: RedvoxApiM_RedvoxPacketM.Sensors.Location.BestLocation.BestTimestamp) -> Bool {
    if lhs.unit != rhs.unit {return false}
    if lhs.mach != rhs.mach {return false}
    if lhs.gps != rhs.gps {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_RedvoxPacketM.Sensors.Xyz: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RedvoxApiM_RedvoxPacketM.Sensors.protoMessageName + ".Xyz"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sensor_description"),
    2: .same(proto: "timestamps"),
    3: .standard(proto: "x_samples"),
    4: .standard(proto: "y_samples"),
    5: .standard(proto: "z_samples"),
    6: .same(proto: "metadata"),
  ]

  fileprivate class _StorageClass {
    var _sensorDescription: String = String()
    var _timestamps: RedvoxApiM_RedvoxPacketM.TimingPayload? = nil
    var _xSamples: RedvoxApiM_RedvoxPacketM.SamplePayload? = nil
    var _ySamples: RedvoxApiM_RedvoxPacketM.SamplePayload? = nil
    var _zSamples: RedvoxApiM_RedvoxPacketM.SamplePayload? = nil
    var _metadata: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sensorDescription = source._sensorDescription
      _timestamps = source._timestamps
      _xSamples = source._xSamples
      _ySamples = source._ySamples
      _zSamples = source._zSamples
      _metadata = source._metadata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._sensorDescription) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._timestamps) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._xSamples) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._ySamples) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._zSamples) }()
        case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._metadata) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._sensorDescription.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sensorDescription, fieldNumber: 1)
      }
      if let v = _storage._timestamps {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._xSamples {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._ySamples {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._zSamples {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._metadata, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_RedvoxPacketM.Sensors.Xyz, rhs: RedvoxApiM_RedvoxPacketM.Sensors.Xyz) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sensorDescription != rhs_storage._sensorDescription {return false}
        if _storage._timestamps != rhs_storage._timestamps {return false}
        if _storage._xSamples != rhs_storage._xSamples {return false}
        if _storage._ySamples != rhs_storage._ySamples {return false}
        if _storage._zSamples != rhs_storage._zSamples {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_RedvoxPacketM.Sensors.Image: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RedvoxApiM_RedvoxPacketM.Sensors.protoMessageName + ".Image"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sensor_description"),
    2: .same(proto: "timestamps"),
    3: .same(proto: "samples"),
    4: .standard(proto: "image_codec"),
    5: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sensorDescription) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timestamps) }()
      case 3: try { try decoder.decodeRepeatedBytesField(value: &self.samples) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.imageCodec) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sensorDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.sensorDescription, fieldNumber: 1)
    }
    if let v = self._timestamps {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.samples.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.samples, fieldNumber: 3)
    }
    if self.imageCodec != .unknown {
      try visitor.visitSingularEnumField(value: self.imageCodec, fieldNumber: 4)
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_RedvoxPacketM.Sensors.Image, rhs: RedvoxApiM_RedvoxPacketM.Sensors.Image) -> Bool {
    if lhs.sensorDescription != rhs.sensorDescription {return false}
    if lhs._timestamps != rhs._timestamps {return false}
    if lhs.samples != rhs.samples {return false}
    if lhs.imageCodec != rhs.imageCodec {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_RedvoxPacketM.Sensors.Image.ImageCodec: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "PNG"),
    2: .same(proto: "JPG"),
    3: .same(proto: "BMP"),
  ]
}

extension RedvoxApiM_RedvoxPacketM.EventStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RedvoxApiM_RedvoxPacketM.protoMessageName + ".EventStream"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "timestamps"),
    3: .same(proto: "events"),
    4: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timestamps) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._timestamps {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 3)
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_RedvoxPacketM.EventStream, rhs: RedvoxApiM_RedvoxPacketM.EventStream) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._timestamps != rhs._timestamps {return false}
    if lhs.events != rhs.events {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_RedvoxPacketM.EventStream.Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RedvoxApiM_RedvoxPacketM.EventStream.protoMessageName + ".Event"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "description"),
    2: .standard(proto: "string_payload"),
    3: .standard(proto: "numeric_payload"),
    4: .standard(proto: "boolean_payload"),
    5: .standard(proto: "byte_payload"),
    6: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.stringPayload) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufDouble>.self, value: &self.numericPayload) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBool>.self, value: &self.booleanPayload) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: &self.bytePayload) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 1)
    }
    if !self.stringPayload.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.stringPayload, fieldNumber: 2)
    }
    if !self.numericPayload.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufDouble>.self, value: self.numericPayload, fieldNumber: 3)
    }
    if !self.booleanPayload.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBool>.self, value: self.booleanPayload, fieldNumber: 4)
    }
    if !self.bytePayload.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: self.bytePayload, fieldNumber: 5)
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_RedvoxPacketM.EventStream.Event, rhs: RedvoxApiM_RedvoxPacketM.EventStream.Event) -> Bool {
    if lhs.description_p != rhs.description_p {return false}
    if lhs.stringPayload != rhs.stringPayload {return false}
    if lhs.numericPayload != rhs.numericPayload {return false}
    if lhs.booleanPayload != rhs.booleanPayload {return false}
    if lhs.bytePayload != rhs.bytePayload {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_RedvoxPacketM.SamplePayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RedvoxApiM_RedvoxPacketM.protoMessageName + ".SamplePayload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unit"),
    2: .same(proto: "values"),
    3: .standard(proto: "value_statistics"),
    4: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.unit) }()
      case 2: try { try decoder.decodeRepeatedFloatField(value: &self.values) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._valueStatistics) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.unit != .unknown {
      try visitor.visitSingularEnumField(value: self.unit, fieldNumber: 1)
    }
    if !self.values.isEmpty {
      try visitor.visitPackedFloatField(value: self.values, fieldNumber: 2)
    }
    if let v = self._valueStatistics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_RedvoxPacketM.SamplePayload, rhs: RedvoxApiM_RedvoxPacketM.SamplePayload) -> Bool {
    if lhs.unit != rhs.unit {return false}
    if lhs.values != rhs.values {return false}
    if lhs._valueStatistics != rhs._valueStatistics {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_RedvoxPacketM.DoubleSamplePayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RedvoxApiM_RedvoxPacketM.protoMessageName + ".DoubleSamplePayload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unit"),
    2: .same(proto: "values"),
    3: .standard(proto: "value_statistics"),
    4: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.unit) }()
      case 2: try { try decoder.decodeRepeatedDoubleField(value: &self.values) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._valueStatistics) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.unit != .unknown {
      try visitor.visitSingularEnumField(value: self.unit, fieldNumber: 1)
    }
    if !self.values.isEmpty {
      try visitor.visitPackedDoubleField(value: self.values, fieldNumber: 2)
    }
    if let v = self._valueStatistics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_RedvoxPacketM.DoubleSamplePayload, rhs: RedvoxApiM_RedvoxPacketM.DoubleSamplePayload) -> Bool {
    if lhs.unit != rhs.unit {return false}
    if lhs.values != rhs.values {return false}
    if lhs._valueStatistics != rhs._valueStatistics {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_RedvoxPacketM.TimingPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RedvoxApiM_RedvoxPacketM.protoMessageName + ".TimingPayload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unit"),
    2: .same(proto: "timestamps"),
    3: .standard(proto: "timestamp_statistics"),
    4: .standard(proto: "mean_sample_rate"),
    5: .standard(proto: "stdev_sample_rate"),
    6: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.unit) }()
      case 2: try { try decoder.decodeRepeatedDoubleField(value: &self.timestamps) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timestampStatistics) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.meanSampleRate) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.stdevSampleRate) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.unit != .unknown {
      try visitor.visitSingularEnumField(value: self.unit, fieldNumber: 1)
    }
    if !self.timestamps.isEmpty {
      try visitor.visitPackedDoubleField(value: self.timestamps, fieldNumber: 2)
    }
    if let v = self._timestampStatistics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.meanSampleRate != 0 {
      try visitor.visitSingularFloatField(value: self.meanSampleRate, fieldNumber: 4)
    }
    if self.stdevSampleRate != 0 {
      try visitor.visitSingularFloatField(value: self.stdevSampleRate, fieldNumber: 5)
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_RedvoxPacketM.TimingPayload, rhs: RedvoxApiM_RedvoxPacketM.TimingPayload) -> Bool {
    if lhs.unit != rhs.unit {return false}
    if lhs.timestamps != rhs.timestamps {return false}
    if lhs._timestampStatistics != rhs._timestampStatistics {return false}
    if lhs.meanSampleRate != rhs.meanSampleRate {return false}
    if lhs.stdevSampleRate != rhs.stdevSampleRate {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_RedvoxPacketM.SummaryStatistics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RedvoxApiM_RedvoxPacketM.protoMessageName + ".SummaryStatistics"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "mean"),
    3: .standard(proto: "standard_deviation"),
    4: .same(proto: "min"),
    5: .same(proto: "max"),
    6: .same(proto: "range"),
    7: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.count) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.mean) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.standardDeviation) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.min) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.max) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.range) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularDoubleField(value: self.count, fieldNumber: 1)
    }
    if self.mean != 0 {
      try visitor.visitSingularDoubleField(value: self.mean, fieldNumber: 2)
    }
    if self.standardDeviation != 0 {
      try visitor.visitSingularDoubleField(value: self.standardDeviation, fieldNumber: 3)
    }
    if self.min != 0 {
      try visitor.visitSingularDoubleField(value: self.min, fieldNumber: 4)
    }
    if self.max != 0 {
      try visitor.visitSingularDoubleField(value: self.max, fieldNumber: 5)
    }
    if self.range != 0 {
      try visitor.visitSingularDoubleField(value: self.range, fieldNumber: 6)
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_RedvoxPacketM.SummaryStatistics, rhs: RedvoxApiM_RedvoxPacketM.SummaryStatistics) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.mean != rhs.mean {return false}
    if lhs.standardDeviation != rhs.standardDeviation {return false}
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.range != rhs.range {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_EncryptedRedvoxPacketM: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EncryptedRedvoxPacketM"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "packet"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.header) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.packet) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.header.isEmpty {
      try visitor.visitSingularBytesField(value: self.header, fieldNumber: 1)
    }
    if !self.packet.isEmpty {
      try visitor.visitSingularBytesField(value: self.packet, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_EncryptedRedvoxPacketM, rhs: RedvoxApiM_EncryptedRedvoxPacketM) -> Bool {
    if lhs.header != rhs.header {return false}
    if lhs.packet != rhs.packet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_EncryptedRedvoxPacketM.Header: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = RedvoxApiM_EncryptedRedvoxPacketM.protoMessageName + ".Header"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "station_id"),
    2: .standard(proto: "station_uuid"),
    3: .standard(proto: "auth_token"),
    4: .standard(proto: "firebase_token"),
    5: .standard(proto: "auth_email"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stationID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.stationUuid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.authToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.firebaseToken) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.authEmail) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stationID.isEmpty {
      try visitor.visitSingularStringField(value: self.stationID, fieldNumber: 1)
    }
    if !self.stationUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.stationUuid, fieldNumber: 2)
    }
    if !self.authToken.isEmpty {
      try visitor.visitSingularStringField(value: self.authToken, fieldNumber: 3)
    }
    if !self.firebaseToken.isEmpty {
      try visitor.visitSingularStringField(value: self.firebaseToken, fieldNumber: 4)
    }
    if !self.authEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.authEmail, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_EncryptedRedvoxPacketM.Header, rhs: RedvoxApiM_EncryptedRedvoxPacketM.Header) -> Bool {
    if lhs.stationID != rhs.stationID {return false}
    if lhs.stationUuid != rhs.stationUuid {return false}
    if lhs.authToken != rhs.authToken {return false}
    if lhs.firebaseToken != rhs.firebaseToken {return false}
    if lhs.authEmail != rhs.authEmail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_AcquisitionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcquisitionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auth_token"),
    2: .standard(proto: "firebase_token"),
    3: .same(proto: "checksum"),
    4: .standard(proto: "is_encrypted"),
    5: .same(proto: "payload"),
    6: .standard(proto: "seq_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.firebaseToken) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.checksum) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isEncrypted) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.seqID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authToken.isEmpty {
      try visitor.visitSingularStringField(value: self.authToken, fieldNumber: 1)
    }
    if !self.firebaseToken.isEmpty {
      try visitor.visitSingularStringField(value: self.firebaseToken, fieldNumber: 2)
    }
    if self.checksum != 0 {
      try visitor.visitSingularInt64Field(value: self.checksum, fieldNumber: 3)
    }
    if self.isEncrypted != false {
      try visitor.visitSingularBoolField(value: self.isEncrypted, fieldNumber: 4)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 5)
    }
    if self.seqID != 0 {
      try visitor.visitSingularInt64Field(value: self.seqID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_AcquisitionRequest, rhs: RedvoxApiM_AcquisitionRequest) -> Bool {
    if lhs.authToken != rhs.authToken {return false}
    if lhs.firebaseToken != rhs.firebaseToken {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.isEncrypted != rhs.isEncrypted {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.seqID != rhs.seqID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_AcquisitionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AcquisitionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "response_type"),
    2: .same(proto: "checksum"),
    3: .same(proto: "details"),
    4: .same(proto: "resend"),
    5: .standard(proto: "seq_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.responseType) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.checksum) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.details) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.resend) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.seqID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.responseType != .unknown {
      try visitor.visitSingularEnumField(value: self.responseType, fieldNumber: 1)
    }
    if self.checksum != 0 {
      try visitor.visitSingularInt64Field(value: self.checksum, fieldNumber: 2)
    }
    if !self.details.isEmpty {
      try visitor.visitSingularStringField(value: self.details, fieldNumber: 3)
    }
    if self.resend != false {
      try visitor.visitSingularBoolField(value: self.resend, fieldNumber: 4)
    }
    if self.seqID != 0 {
      try visitor.visitSingularInt64Field(value: self.seqID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_AcquisitionResponse, rhs: RedvoxApiM_AcquisitionResponse) -> Bool {
    if lhs.responseType != rhs.responseType {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.details != rhs.details {return false}
    if lhs.resend != rhs.resend {return false}
    if lhs.seqID != rhs.seqID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_AcquisitionResponse.ResponseType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "OK"),
    2: .same(proto: "AUTH_ERROR"),
    3: .same(proto: "DATA_ERROR"),
    4: .same(proto: "OTHER_ERROR"),
  ]
}

extension RedvoxApiM_SynchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SynchRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "station_id"),
    2: .standard(proto: "station_uuid"),
    3: .standard(proto: "seq_id"),
    4: .standard(proto: "sub_seq_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stationID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.stationUuid) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.seqID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.subSeqID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stationID.isEmpty {
      try visitor.visitSingularStringField(value: self.stationID, fieldNumber: 1)
    }
    if !self.stationUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.stationUuid, fieldNumber: 2)
    }
    if self.seqID != 0 {
      try visitor.visitSingularUInt32Field(value: self.seqID, fieldNumber: 3)
    }
    if self.subSeqID != 0 {
      try visitor.visitSingularUInt32Field(value: self.subSeqID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_SynchRequest, rhs: RedvoxApiM_SynchRequest) -> Bool {
    if lhs.stationID != rhs.stationID {return false}
    if lhs.stationUuid != rhs.stationUuid {return false}
    if lhs.seqID != rhs.seqID {return false}
    if lhs.subSeqID != rhs.subSeqID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RedvoxApiM_SynchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SynchResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "station_id"),
    2: .standard(proto: "station_uuid"),
    3: .standard(proto: "seq_id"),
    4: .standard(proto: "sub_seq_id"),
    5: .standard(proto: "recv_ts_us"),
    6: .standard(proto: "send_ts_us"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stationID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.stationUuid) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.seqID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.subSeqID) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.recvTsUs) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.sendTsUs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stationID.isEmpty {
      try visitor.visitSingularStringField(value: self.stationID, fieldNumber: 1)
    }
    if !self.stationUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.stationUuid, fieldNumber: 2)
    }
    if self.seqID != 0 {
      try visitor.visitSingularUInt32Field(value: self.seqID, fieldNumber: 3)
    }
    if self.subSeqID != 0 {
      try visitor.visitSingularUInt32Field(value: self.subSeqID, fieldNumber: 4)
    }
    if self.recvTsUs != 0 {
      try visitor.visitSingularUInt64Field(value: self.recvTsUs, fieldNumber: 5)
    }
    if self.sendTsUs != 0 {
      try visitor.visitSingularUInt64Field(value: self.sendTsUs, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RedvoxApiM_SynchResponse, rhs: RedvoxApiM_SynchResponse) -> Bool {
    if lhs.stationID != rhs.stationID {return false}
    if lhs.stationUuid != rhs.stationUuid {return false}
    if lhs.seqID != rhs.seqID {return false}
    if lhs.subSeqID != rhs.subSeqID {return false}
    if lhs.recvTsUs != rhs.recvTsUs {return false}
    if lhs.sendTsUs != rhs.sendTsUs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
