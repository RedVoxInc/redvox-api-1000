// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: src/redvox_api_m/redvox_api_m.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "src/redvox_api_m/RedvoxApiM.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - RedvoxApiMRoot

@implementation RedvoxApiMRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - RedvoxApiMRoot_FileDescriptor

static GPBFileDescriptor *RedvoxApiMRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"redvox_api_m"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - RedvoxPacketM

@implementation RedvoxPacketM

@dynamic api;
@dynamic subApi;
@dynamic hasStationInformation, stationInformation;
@dynamic hasTimingInformation, timingInformation;
@dynamic hasSensors, sensors;
@dynamic eventStreamsArray, eventStreamsArray_Count;
@dynamic metadata, metadata_Count;

typedef struct RedvoxPacketM__storage_ {
  uint32_t _has_storage_[1];
  float api;
  float subApi;
  RedvoxPacketM_StationInformation *stationInformation;
  RedvoxPacketM_TimingInformation *timingInformation;
  RedvoxPacketM_Sensors *sensors;
  NSMutableArray *eventStreamsArray;
  NSMutableDictionary *metadata;
} RedvoxPacketM__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "api",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_FieldNumber_Api,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedvoxPacketM__storage_, api),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "subApi",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_FieldNumber_SubApi,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedvoxPacketM__storage_, subApi),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "stationInformation",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_StationInformation),
        .number = RedvoxPacketM_FieldNumber_StationInformation,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RedvoxPacketM__storage_, stationInformation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timingInformation",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_TimingInformation),
        .number = RedvoxPacketM_FieldNumber_TimingInformation,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RedvoxPacketM__storage_, timingInformation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sensors",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_Sensors),
        .number = RedvoxPacketM_FieldNumber_Sensors,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RedvoxPacketM__storage_, sensors),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "eventStreamsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_EventStream),
        .number = RedvoxPacketM_FieldNumber_EventStreamsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM__storage_, eventStreamsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedvoxPacketM class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedvoxPacketM__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum RedvoxPacketM_Unit

GPBEnumDescriptor *RedvoxPacketM_Unit_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000MetersPerSecondSquared\000Kilopasca"
        "l\000RadiansPerSecond\000DecimalDegrees\000Meters"
        "\000MetersPerSecond\000Microtesla\000LsbPlusMinus"
        "Counts\000MicrosecondsSinceUnixEpoch\000Decibe"
        "l\000DegreesCelsius\000Byte\000Percentage\000Radians"
        "\000Microamperes\000Centimeters\000NormalizedCoun"
        "ts\000Lux\000Unitless\000Pcm\000";
    static const int32_t values[] = {
        RedvoxPacketM_Unit_Unknown,
        RedvoxPacketM_Unit_MetersPerSecondSquared,
        RedvoxPacketM_Unit_Kilopascal,
        RedvoxPacketM_Unit_RadiansPerSecond,
        RedvoxPacketM_Unit_DecimalDegrees,
        RedvoxPacketM_Unit_Meters,
        RedvoxPacketM_Unit_MetersPerSecond,
        RedvoxPacketM_Unit_Microtesla,
        RedvoxPacketM_Unit_LsbPlusMinusCounts,
        RedvoxPacketM_Unit_MicrosecondsSinceUnixEpoch,
        RedvoxPacketM_Unit_Decibel,
        RedvoxPacketM_Unit_DegreesCelsius,
        RedvoxPacketM_Unit_Byte,
        RedvoxPacketM_Unit_Percentage,
        RedvoxPacketM_Unit_Radians,
        RedvoxPacketM_Unit_Microamperes,
        RedvoxPacketM_Unit_Centimeters,
        RedvoxPacketM_Unit_NormalizedCounts,
        RedvoxPacketM_Unit_Lux,
        RedvoxPacketM_Unit_Unitless,
        RedvoxPacketM_Unit_Pcm,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RedvoxPacketM_Unit)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RedvoxPacketM_Unit_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RedvoxPacketM_Unit_IsValidValue(int32_t value__) {
  switch (value__) {
    case RedvoxPacketM_Unit_Unknown:
    case RedvoxPacketM_Unit_MetersPerSecondSquared:
    case RedvoxPacketM_Unit_Kilopascal:
    case RedvoxPacketM_Unit_RadiansPerSecond:
    case RedvoxPacketM_Unit_DecimalDegrees:
    case RedvoxPacketM_Unit_Meters:
    case RedvoxPacketM_Unit_MetersPerSecond:
    case RedvoxPacketM_Unit_Microtesla:
    case RedvoxPacketM_Unit_LsbPlusMinusCounts:
    case RedvoxPacketM_Unit_MicrosecondsSinceUnixEpoch:
    case RedvoxPacketM_Unit_Decibel:
    case RedvoxPacketM_Unit_DegreesCelsius:
    case RedvoxPacketM_Unit_Byte:
    case RedvoxPacketM_Unit_Percentage:
    case RedvoxPacketM_Unit_Radians:
    case RedvoxPacketM_Unit_Microamperes:
    case RedvoxPacketM_Unit_Centimeters:
    case RedvoxPacketM_Unit_NormalizedCounts:
    case RedvoxPacketM_Unit_Lux:
    case RedvoxPacketM_Unit_Unitless:
    case RedvoxPacketM_Unit_Pcm:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RedvoxPacketM_StationInformation

@implementation RedvoxPacketM_StationInformation

@dynamic id_p;
@dynamic uuid;
@dynamic description_p;
@dynamic authId;
@dynamic make;
@dynamic model;
@dynamic os;
@dynamic osVersion;
@dynamic appVersion;
@dynamic isPrivate;
@dynamic hasAppSettings, appSettings;
@dynamic hasStationMetrics, stationMetrics;
@dynamic hasServiceUrls, serviceUrls;
@dynamic metadata, metadata_Count;

typedef struct RedvoxPacketM_StationInformation__storage_ {
  uint32_t _has_storage_[1];
  RedvoxPacketM_StationInformation_OsType os;
  NSString *id_p;
  NSString *uuid;
  NSString *description_p;
  NSString *authId;
  NSString *make;
  NSString *model;
  NSString *osVersion;
  NSString *appVersion;
  RedvoxPacketM_StationInformation_AppSettings *appSettings;
  RedvoxPacketM_StationInformation_StationMetrics *stationMetrics;
  RedvoxPacketM_StationInformation_ServiceUrls *serviceUrls;
  NSMutableDictionary *metadata;
} RedvoxPacketM_StationInformation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "uuid",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_FieldNumber_Uuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation__storage_, uuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_FieldNumber_Description_p,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "authId",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_FieldNumber_AuthId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation__storage_, authId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "make",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_FieldNumber_Make,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation__storage_, make),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "model",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_FieldNumber_Model,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation__storage_, model),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "os",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_StationInformation_OsType_EnumDescriptor,
        .number = RedvoxPacketM_StationInformation_FieldNumber_Os,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation__storage_, os),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "osVersion",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_FieldNumber_OsVersion,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation__storage_, osVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "appVersion",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_FieldNumber_AppVersion,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation__storage_, appVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isPrivate",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_FieldNumber_IsPrivate,
        .hasIndex = 9,
        .offset = 10,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "appSettings",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_StationInformation_AppSettings),
        .number = RedvoxPacketM_StationInformation_FieldNumber_AppSettings,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation__storage_, appSettings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stationMetrics",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_StationInformation_StationMetrics),
        .number = RedvoxPacketM_StationInformation_FieldNumber_StationMetrics,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation__storage_, stationMetrics),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "serviceUrls",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_StationInformation_ServiceUrls),
        .number = RedvoxPacketM_StationInformation_FieldNumber_ServiceUrls,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation__storage_, serviceUrls),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedvoxPacketM_StationInformation class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedvoxPacketM_StationInformation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RedvoxPacketM)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RedvoxPacketM_StationInformation_Os_RawValue(RedvoxPacketM_StationInformation *message) {
  GPBDescriptor *descriptor = [RedvoxPacketM_StationInformation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_StationInformation_FieldNumber_Os];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacketM_StationInformation_Os_RawValue(RedvoxPacketM_StationInformation *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacketM_StationInformation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_StationInformation_FieldNumber_Os];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RedvoxPacketM_StationInformation_OsType

GPBEnumDescriptor *RedvoxPacketM_StationInformation_OsType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UnknownOs\000Android\000Ios\000Osx\000Linux\000Windows\000";
    static const int32_t values[] = {
        RedvoxPacketM_StationInformation_OsType_UnknownOs,
        RedvoxPacketM_StationInformation_OsType_Android,
        RedvoxPacketM_StationInformation_OsType_Ios,
        RedvoxPacketM_StationInformation_OsType_Osx,
        RedvoxPacketM_StationInformation_OsType_Linux,
        RedvoxPacketM_StationInformation_OsType_Windows,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RedvoxPacketM_StationInformation_OsType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RedvoxPacketM_StationInformation_OsType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RedvoxPacketM_StationInformation_OsType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RedvoxPacketM_StationInformation_OsType_UnknownOs:
    case RedvoxPacketM_StationInformation_OsType_Android:
    case RedvoxPacketM_StationInformation_OsType_Ios:
    case RedvoxPacketM_StationInformation_OsType_Osx:
    case RedvoxPacketM_StationInformation_OsType_Linux:
    case RedvoxPacketM_StationInformation_OsType_Windows:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RedvoxPacketM_StationInformation_ServiceUrls

@implementation RedvoxPacketM_StationInformation_ServiceUrls

@dynamic authServer;
@dynamic synchServer;
@dynamic acquisitionServer;
@dynamic metadata, metadata_Count;

typedef struct RedvoxPacketM_StationInformation_ServiceUrls__storage_ {
  uint32_t _has_storage_[1];
  NSString *authServer;
  NSString *synchServer;
  NSString *acquisitionServer;
  NSMutableDictionary *metadata;
} RedvoxPacketM_StationInformation_ServiceUrls__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "authServer",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_ServiceUrls_FieldNumber_AuthServer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_ServiceUrls__storage_, authServer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "synchServer",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_ServiceUrls_FieldNumber_SynchServer,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_ServiceUrls__storage_, synchServer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "acquisitionServer",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_ServiceUrls_FieldNumber_AcquisitionServer,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_ServiceUrls__storage_, acquisitionServer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_ServiceUrls_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_ServiceUrls__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedvoxPacketM_StationInformation_ServiceUrls class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedvoxPacketM_StationInformation_ServiceUrls__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RedvoxPacketM_StationInformation)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RedvoxPacketM_StationInformation_StationMetrics

@implementation RedvoxPacketM_StationInformation_StationMetrics

@dynamic hasTimestamps, timestamps;
@dynamic networkTypeArray, networkTypeArray_Count;
@dynamic cellServiceStateArray, cellServiceStateArray_Count;
@dynamic hasNetworkStrength, networkStrength;
@dynamic hasTemperature, temperature;
@dynamic hasBattery, battery;
@dynamic hasBatteryCurrent, batteryCurrent;
@dynamic hasAvailableRam, availableRam;
@dynamic hasAvailableDisk, availableDisk;
@dynamic hasCpuUtilization, cpuUtilization;
@dynamic powerStateArray, powerStateArray_Count;
@dynamic wifiWakeLockArray, wifiWakeLockArray_Count;
@dynamic metadata, metadata_Count;

typedef struct RedvoxPacketM_StationInformation_StationMetrics__storage_ {
  uint32_t _has_storage_[1];
  RedvoxPacketM_TimingPayload *timestamps;
  GPBEnumArray *networkTypeArray;
  GPBEnumArray *cellServiceStateArray;
  RedvoxPacketM_SamplePayload *networkStrength;
  RedvoxPacketM_SamplePayload *temperature;
  RedvoxPacketM_SamplePayload *battery;
  RedvoxPacketM_SamplePayload *batteryCurrent;
  RedvoxPacketM_SamplePayload *availableRam;
  RedvoxPacketM_SamplePayload *availableDisk;
  RedvoxPacketM_SamplePayload *cpuUtilization;
  GPBEnumArray *powerStateArray;
  GPBEnumArray *wifiWakeLockArray;
  NSMutableDictionary *metadata;
} RedvoxPacketM_StationInformation_StationMetrics__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamps",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_TimingPayload),
        .number = RedvoxPacketM_StationInformation_StationMetrics_FieldNumber_Timestamps,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_StationMetrics__storage_, timestamps),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "networkTypeArray",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_StationInformation_StationMetrics_NetworkType_EnumDescriptor,
        .number = RedvoxPacketM_StationInformation_StationMetrics_FieldNumber_NetworkTypeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_StationMetrics__storage_, networkTypeArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "cellServiceStateArray",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_StationInformation_StationMetrics_CellServiceState_EnumDescriptor,
        .number = RedvoxPacketM_StationInformation_StationMetrics_FieldNumber_CellServiceStateArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_StationMetrics__storage_, cellServiceStateArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "networkStrength",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_SamplePayload),
        .number = RedvoxPacketM_StationInformation_StationMetrics_FieldNumber_NetworkStrength,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_StationMetrics__storage_, networkStrength),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "temperature",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_SamplePayload),
        .number = RedvoxPacketM_StationInformation_StationMetrics_FieldNumber_Temperature,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_StationMetrics__storage_, temperature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "battery",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_SamplePayload),
        .number = RedvoxPacketM_StationInformation_StationMetrics_FieldNumber_Battery,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_StationMetrics__storage_, battery),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "batteryCurrent",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_SamplePayload),
        .number = RedvoxPacketM_StationInformation_StationMetrics_FieldNumber_BatteryCurrent,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_StationMetrics__storage_, batteryCurrent),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "availableRam",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_SamplePayload),
        .number = RedvoxPacketM_StationInformation_StationMetrics_FieldNumber_AvailableRam,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_StationMetrics__storage_, availableRam),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "availableDisk",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_SamplePayload),
        .number = RedvoxPacketM_StationInformation_StationMetrics_FieldNumber_AvailableDisk,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_StationMetrics__storage_, availableDisk),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cpuUtilization",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_SamplePayload),
        .number = RedvoxPacketM_StationInformation_StationMetrics_FieldNumber_CpuUtilization,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_StationMetrics__storage_, cpuUtilization),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "powerStateArray",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_StationInformation_StationMetrics_PowerState_EnumDescriptor,
        .number = RedvoxPacketM_StationInformation_StationMetrics_FieldNumber_PowerStateArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_StationMetrics__storage_, powerStateArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "wifiWakeLockArray",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_StationInformation_StationMetrics_WifiWakeLock_EnumDescriptor,
        .number = RedvoxPacketM_StationInformation_StationMetrics_FieldNumber_WifiWakeLockArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_StationMetrics__storage_, wifiWakeLockArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_StationMetrics_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_StationMetrics__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedvoxPacketM_StationInformation_StationMetrics class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedvoxPacketM_StationInformation_StationMetrics__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RedvoxPacketM_StationInformation)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum RedvoxPacketM_StationInformation_StationMetrics_NetworkType

GPBEnumDescriptor *RedvoxPacketM_StationInformation_StationMetrics_NetworkType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UnknownNetwork\000NoNetwork\000Wifi\000Cellular\000W"
        "ired\000";
    static const int32_t values[] = {
        RedvoxPacketM_StationInformation_StationMetrics_NetworkType_UnknownNetwork,
        RedvoxPacketM_StationInformation_StationMetrics_NetworkType_NoNetwork,
        RedvoxPacketM_StationInformation_StationMetrics_NetworkType_Wifi,
        RedvoxPacketM_StationInformation_StationMetrics_NetworkType_Cellular,
        RedvoxPacketM_StationInformation_StationMetrics_NetworkType_Wired,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RedvoxPacketM_StationInformation_StationMetrics_NetworkType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RedvoxPacketM_StationInformation_StationMetrics_NetworkType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RedvoxPacketM_StationInformation_StationMetrics_NetworkType_IsValidValue(int32_t value__) {
  switch (value__) {
    case RedvoxPacketM_StationInformation_StationMetrics_NetworkType_UnknownNetwork:
    case RedvoxPacketM_StationInformation_StationMetrics_NetworkType_NoNetwork:
    case RedvoxPacketM_StationInformation_StationMetrics_NetworkType_Wifi:
    case RedvoxPacketM_StationInformation_StationMetrics_NetworkType_Cellular:
    case RedvoxPacketM_StationInformation_StationMetrics_NetworkType_Wired:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum RedvoxPacketM_StationInformation_StationMetrics_WifiWakeLock

GPBEnumDescriptor *RedvoxPacketM_StationInformation_StationMetrics_WifiWakeLock_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "None\000HighPerf\000LowLatency\000Other\000";
    static const int32_t values[] = {
        RedvoxPacketM_StationInformation_StationMetrics_WifiWakeLock_None,
        RedvoxPacketM_StationInformation_StationMetrics_WifiWakeLock_HighPerf,
        RedvoxPacketM_StationInformation_StationMetrics_WifiWakeLock_LowLatency,
        RedvoxPacketM_StationInformation_StationMetrics_WifiWakeLock_Other,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RedvoxPacketM_StationInformation_StationMetrics_WifiWakeLock)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RedvoxPacketM_StationInformation_StationMetrics_WifiWakeLock_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RedvoxPacketM_StationInformation_StationMetrics_WifiWakeLock_IsValidValue(int32_t value__) {
  switch (value__) {
    case RedvoxPacketM_StationInformation_StationMetrics_WifiWakeLock_None:
    case RedvoxPacketM_StationInformation_StationMetrics_WifiWakeLock_HighPerf:
    case RedvoxPacketM_StationInformation_StationMetrics_WifiWakeLock_LowLatency:
    case RedvoxPacketM_StationInformation_StationMetrics_WifiWakeLock_Other:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum RedvoxPacketM_StationInformation_StationMetrics_CellServiceState

GPBEnumDescriptor *RedvoxPacketM_StationInformation_StationMetrics_CellServiceState_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Emergency\000Nominal\000OutOfService\000P"
        "owerOff\000";
    static const int32_t values[] = {
        RedvoxPacketM_StationInformation_StationMetrics_CellServiceState_Unknown,
        RedvoxPacketM_StationInformation_StationMetrics_CellServiceState_Emergency,
        RedvoxPacketM_StationInformation_StationMetrics_CellServiceState_Nominal,
        RedvoxPacketM_StationInformation_StationMetrics_CellServiceState_OutOfService,
        RedvoxPacketM_StationInformation_StationMetrics_CellServiceState_PowerOff,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RedvoxPacketM_StationInformation_StationMetrics_CellServiceState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RedvoxPacketM_StationInformation_StationMetrics_CellServiceState_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RedvoxPacketM_StationInformation_StationMetrics_CellServiceState_IsValidValue(int32_t value__) {
  switch (value__) {
    case RedvoxPacketM_StationInformation_StationMetrics_CellServiceState_Unknown:
    case RedvoxPacketM_StationInformation_StationMetrics_CellServiceState_Emergency:
    case RedvoxPacketM_StationInformation_StationMetrics_CellServiceState_Nominal:
    case RedvoxPacketM_StationInformation_StationMetrics_CellServiceState_OutOfService:
    case RedvoxPacketM_StationInformation_StationMetrics_CellServiceState_PowerOff:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum RedvoxPacketM_StationInformation_StationMetrics_PowerState

GPBEnumDescriptor *RedvoxPacketM_StationInformation_StationMetrics_PowerState_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UnknownPowerState\000Unplugged\000Charging\000Cha"
        "rged\000";
    static const int32_t values[] = {
        RedvoxPacketM_StationInformation_StationMetrics_PowerState_UnknownPowerState,
        RedvoxPacketM_StationInformation_StationMetrics_PowerState_Unplugged,
        RedvoxPacketM_StationInformation_StationMetrics_PowerState_Charging,
        RedvoxPacketM_StationInformation_StationMetrics_PowerState_Charged,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RedvoxPacketM_StationInformation_StationMetrics_PowerState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RedvoxPacketM_StationInformation_StationMetrics_PowerState_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RedvoxPacketM_StationInformation_StationMetrics_PowerState_IsValidValue(int32_t value__) {
  switch (value__) {
    case RedvoxPacketM_StationInformation_StationMetrics_PowerState_UnknownPowerState:
    case RedvoxPacketM_StationInformation_StationMetrics_PowerState_Unplugged:
    case RedvoxPacketM_StationInformation_StationMetrics_PowerState_Charging:
    case RedvoxPacketM_StationInformation_StationMetrics_PowerState_Charged:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RedvoxPacketM_StationInformation_AppSettings

@implementation RedvoxPacketM_StationInformation_AppSettings

@dynamic audioSamplingRate;
@dynamic audioSourceTuning;
@dynamic additionalInputSensorsArray, additionalInputSensorsArray_Count;
@dynamic automaticallyRecord;
@dynamic launchAtPowerUp;
@dynamic stationId;
@dynamic stationDescription;
@dynamic pushToServer;
@dynamic publishDataAsPrivate;
@dynamic scrambleAudioData;
@dynamic provideBackfill;
@dynamic removeSensorDcOffset;
@dynamic fftOverlap;
@dynamic useCustomTimeSyncServer;
@dynamic timeSyncServerURL;
@dynamic useCustomDataServer;
@dynamic dataServerURL;
@dynamic useCustomAuthServer;
@dynamic authServerURL;
@dynamic autoDeleteDataFiles;
@dynamic storageSpaceAllowance;
@dynamic useSdCardForDataStorage;
@dynamic useLocationServices;
@dynamic useLatitude;
@dynamic useLongitude;
@dynamic useAltitude;
@dynamic metadata, metadata_Count;

typedef struct RedvoxPacketM_StationInformation_AppSettings__storage_ {
  uint32_t _has_storage_[2];
  RedvoxPacketM_StationInformation_AppSettings_AudioSamplingRate audioSamplingRate;
  RedvoxPacketM_StationInformation_AppSettings_AudioSourceTuning audioSourceTuning;
  RedvoxPacketM_StationInformation_AppSettings_FftOverlap fftOverlap;
  float storageSpaceAllowance;
  float useAltitude;
  GPBEnumArray *additionalInputSensorsArray;
  NSString *stationId;
  NSString *stationDescription;
  NSString *timeSyncServerURL;
  NSString *dataServerURL;
  NSString *authServerURL;
  NSMutableDictionary *metadata;
  double useLatitude;
  double useLongitude;
} RedvoxPacketM_StationInformation_AppSettings__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "audioSamplingRate",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_StationInformation_AppSettings_AudioSamplingRate_EnumDescriptor,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_AudioSamplingRate,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_AppSettings__storage_, audioSamplingRate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "audioSourceTuning",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_StationInformation_AppSettings_AudioSourceTuning_EnumDescriptor,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_AudioSourceTuning,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_AppSettings__storage_, audioSourceTuning),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "additionalInputSensorsArray",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_StationInformation_AppSettings_InputSensor_EnumDescriptor,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_AdditionalInputSensorsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_AppSettings__storage_, additionalInputSensorsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "automaticallyRecord",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_AutomaticallyRecord,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "launchAtPowerUp",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_LaunchAtPowerUp,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "stationId",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_StationId,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_AppSettings__storage_, stationId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stationDescription",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_StationDescription,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_AppSettings__storage_, stationDescription),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pushToServer",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_PushToServer,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "publishDataAsPrivate",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_PublishDataAsPrivate,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "scrambleAudioData",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_ScrambleAudioData,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "provideBackfill",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_ProvideBackfill,
        .hasIndex = 14,
        .offset = 15,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "removeSensorDcOffset",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_RemoveSensorDcOffset,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "fftOverlap",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_StationInformation_AppSettings_FftOverlap_EnumDescriptor,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_FftOverlap,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_AppSettings__storage_, fftOverlap),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "useCustomTimeSyncServer",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_UseCustomTimeSyncServer,
        .hasIndex = 19,
        .offset = 20,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "timeSyncServerURL",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_TimeSyncServerURL,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_AppSettings__storage_, timeSyncServerURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "useCustomDataServer",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_UseCustomDataServer,
        .hasIndex = 22,
        .offset = 23,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "dataServerURL",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_DataServerURL,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_AppSettings__storage_, dataServerURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "useCustomAuthServer",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_UseCustomAuthServer,
        .hasIndex = 25,
        .offset = 26,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "authServerURL",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_AuthServerURL,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_AppSettings__storage_, authServerURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "autoDeleteDataFiles",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_AutoDeleteDataFiles,
        .hasIndex = 28,
        .offset = 29,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "storageSpaceAllowance",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_StorageSpaceAllowance,
        .hasIndex = 30,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_AppSettings__storage_, storageSpaceAllowance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "useSdCardForDataStorage",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_UseSdCardForDataStorage,
        .hasIndex = 31,
        .offset = 32,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "useLocationServices",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_UseLocationServices,
        .hasIndex = 33,
        .offset = 34,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "useLatitude",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_UseLatitude,
        .hasIndex = 35,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_AppSettings__storage_, useLatitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "useLongitude",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_UseLongitude,
        .hasIndex = 36,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_AppSettings__storage_, useLongitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "useAltitude",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_UseAltitude,
        .hasIndex = 37,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_AppSettings__storage_, useAltitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_StationInformation_AppSettings_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_StationInformation_AppSettings__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedvoxPacketM_StationInformation_AppSettings class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedvoxPacketM_StationInformation_AppSettings__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\017\004\244\246\241!!\000\021\004\246\241!!\000\023\004\246\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RedvoxPacketM_StationInformation)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RedvoxPacketM_StationInformation_AppSettings_AudioSamplingRate_RawValue(RedvoxPacketM_StationInformation_AppSettings *message) {
  GPBDescriptor *descriptor = [RedvoxPacketM_StationInformation_AppSettings descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_StationInformation_AppSettings_FieldNumber_AudioSamplingRate];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacketM_StationInformation_AppSettings_AudioSamplingRate_RawValue(RedvoxPacketM_StationInformation_AppSettings *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacketM_StationInformation_AppSettings descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_StationInformation_AppSettings_FieldNumber_AudioSamplingRate];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t RedvoxPacketM_StationInformation_AppSettings_AudioSourceTuning_RawValue(RedvoxPacketM_StationInformation_AppSettings *message) {
  GPBDescriptor *descriptor = [RedvoxPacketM_StationInformation_AppSettings descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_StationInformation_AppSettings_FieldNumber_AudioSourceTuning];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacketM_StationInformation_AppSettings_AudioSourceTuning_RawValue(RedvoxPacketM_StationInformation_AppSettings *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacketM_StationInformation_AppSettings descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_StationInformation_AppSettings_FieldNumber_AudioSourceTuning];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t RedvoxPacketM_StationInformation_AppSettings_FftOverlap_RawValue(RedvoxPacketM_StationInformation_AppSettings *message) {
  GPBDescriptor *descriptor = [RedvoxPacketM_StationInformation_AppSettings descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_StationInformation_AppSettings_FieldNumber_FftOverlap];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacketM_StationInformation_AppSettings_FftOverlap_RawValue(RedvoxPacketM_StationInformation_AppSettings *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacketM_StationInformation_AppSettings descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_StationInformation_AppSettings_FieldNumber_FftOverlap];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RedvoxPacketM_StationInformation_AppSettings_FftOverlap

GPBEnumDescriptor *RedvoxPacketM_StationInformation_AppSettings_FftOverlap_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Percent25\000Percent50\000Percent75\000";
    static const int32_t values[] = {
        RedvoxPacketM_StationInformation_AppSettings_FftOverlap_Unknown,
        RedvoxPacketM_StationInformation_AppSettings_FftOverlap_Percent25,
        RedvoxPacketM_StationInformation_AppSettings_FftOverlap_Percent50,
        RedvoxPacketM_StationInformation_AppSettings_FftOverlap_Percent75,
    };
    static const char *extraTextFormatInfo = "\003\001g\202\000\002g\202\000\003g\202\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RedvoxPacketM_StationInformation_AppSettings_FftOverlap)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RedvoxPacketM_StationInformation_AppSettings_FftOverlap_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RedvoxPacketM_StationInformation_AppSettings_FftOverlap_IsValidValue(int32_t value__) {
  switch (value__) {
    case RedvoxPacketM_StationInformation_AppSettings_FftOverlap_Unknown:
    case RedvoxPacketM_StationInformation_AppSettings_FftOverlap_Percent25:
    case RedvoxPacketM_StationInformation_AppSettings_FftOverlap_Percent50:
    case RedvoxPacketM_StationInformation_AppSettings_FftOverlap_Percent75:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum RedvoxPacketM_StationInformation_AppSettings_AudioSamplingRate

GPBEnumDescriptor *RedvoxPacketM_StationInformation_AppSettings_AudioSamplingRate_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UnknownSamplingRate\000Hz80\000Hz800\000Hz8000\000Hz"
        "16000\000Hz48000\000";
    static const int32_t values[] = {
        RedvoxPacketM_StationInformation_AppSettings_AudioSamplingRate_UnknownSamplingRate,
        RedvoxPacketM_StationInformation_AppSettings_AudioSamplingRate_Hz80,
        RedvoxPacketM_StationInformation_AppSettings_AudioSamplingRate_Hz800,
        RedvoxPacketM_StationInformation_AppSettings_AudioSamplingRate_Hz8000,
        RedvoxPacketM_StationInformation_AppSettings_AudioSamplingRate_Hz16000,
        RedvoxPacketM_StationInformation_AppSettings_AudioSamplingRate_Hz48000,
    };
    static const char *extraTextFormatInfo = "\005\001b\202\000\002b\203\000\003b\204\000\004b\205\000\005b\205\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RedvoxPacketM_StationInformation_AppSettings_AudioSamplingRate)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RedvoxPacketM_StationInformation_AppSettings_AudioSamplingRate_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RedvoxPacketM_StationInformation_AppSettings_AudioSamplingRate_IsValidValue(int32_t value__) {
  switch (value__) {
    case RedvoxPacketM_StationInformation_AppSettings_AudioSamplingRate_UnknownSamplingRate:
    case RedvoxPacketM_StationInformation_AppSettings_AudioSamplingRate_Hz80:
    case RedvoxPacketM_StationInformation_AppSettings_AudioSamplingRate_Hz800:
    case RedvoxPacketM_StationInformation_AppSettings_AudioSamplingRate_Hz8000:
    case RedvoxPacketM_StationInformation_AppSettings_AudioSamplingRate_Hz16000:
    case RedvoxPacketM_StationInformation_AppSettings_AudioSamplingRate_Hz48000:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum RedvoxPacketM_StationInformation_AppSettings_AudioSourceTuning

GPBEnumDescriptor *RedvoxPacketM_StationInformation_AppSettings_AudioSourceTuning_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UnknownTuning\000InfrasoundTuning\000LowAudioT"
        "uning\000AudioTuning\000";
    static const int32_t values[] = {
        RedvoxPacketM_StationInformation_AppSettings_AudioSourceTuning_UnknownTuning,
        RedvoxPacketM_StationInformation_AppSettings_AudioSourceTuning_InfrasoundTuning,
        RedvoxPacketM_StationInformation_AppSettings_AudioSourceTuning_LowAudioTuning,
        RedvoxPacketM_StationInformation_AppSettings_AudioSourceTuning_AudioTuning,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RedvoxPacketM_StationInformation_AppSettings_AudioSourceTuning)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RedvoxPacketM_StationInformation_AppSettings_AudioSourceTuning_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RedvoxPacketM_StationInformation_AppSettings_AudioSourceTuning_IsValidValue(int32_t value__) {
  switch (value__) {
    case RedvoxPacketM_StationInformation_AppSettings_AudioSourceTuning_UnknownTuning:
    case RedvoxPacketM_StationInformation_AppSettings_AudioSourceTuning_InfrasoundTuning:
    case RedvoxPacketM_StationInformation_AppSettings_AudioSourceTuning_LowAudioTuning:
    case RedvoxPacketM_StationInformation_AppSettings_AudioSourceTuning_AudioTuning:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum RedvoxPacketM_StationInformation_AppSettings_InputSensor

GPBEnumDescriptor *RedvoxPacketM_StationInformation_AppSettings_InputSensor_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UnknownSensor\000Accelerometer\000AmbientTempe"
        "rature\000Audio\000CompressedAudio\000Gravity\000Gyr"
        "oscope\000Image\000Light\000LinearAcceleration\000Lo"
        "cation\000Magnetometer\000Orientation\000Pressure"
        "\000Proximity\000RelativeHumidity\000RotationVect"
        "or\000";
    static const int32_t values[] = {
        RedvoxPacketM_StationInformation_AppSettings_InputSensor_UnknownSensor,
        RedvoxPacketM_StationInformation_AppSettings_InputSensor_Accelerometer,
        RedvoxPacketM_StationInformation_AppSettings_InputSensor_AmbientTemperature,
        RedvoxPacketM_StationInformation_AppSettings_InputSensor_Audio,
        RedvoxPacketM_StationInformation_AppSettings_InputSensor_CompressedAudio,
        RedvoxPacketM_StationInformation_AppSettings_InputSensor_Gravity,
        RedvoxPacketM_StationInformation_AppSettings_InputSensor_Gyroscope,
        RedvoxPacketM_StationInformation_AppSettings_InputSensor_Image,
        RedvoxPacketM_StationInformation_AppSettings_InputSensor_Light,
        RedvoxPacketM_StationInformation_AppSettings_InputSensor_LinearAcceleration,
        RedvoxPacketM_StationInformation_AppSettings_InputSensor_Location,
        RedvoxPacketM_StationInformation_AppSettings_InputSensor_Magnetometer,
        RedvoxPacketM_StationInformation_AppSettings_InputSensor_Orientation,
        RedvoxPacketM_StationInformation_AppSettings_InputSensor_Pressure,
        RedvoxPacketM_StationInformation_AppSettings_InputSensor_Proximity,
        RedvoxPacketM_StationInformation_AppSettings_InputSensor_RelativeHumidity,
        RedvoxPacketM_StationInformation_AppSettings_InputSensor_RotationVector,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RedvoxPacketM_StationInformation_AppSettings_InputSensor)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RedvoxPacketM_StationInformation_AppSettings_InputSensor_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RedvoxPacketM_StationInformation_AppSettings_InputSensor_IsValidValue(int32_t value__) {
  switch (value__) {
    case RedvoxPacketM_StationInformation_AppSettings_InputSensor_UnknownSensor:
    case RedvoxPacketM_StationInformation_AppSettings_InputSensor_Accelerometer:
    case RedvoxPacketM_StationInformation_AppSettings_InputSensor_AmbientTemperature:
    case RedvoxPacketM_StationInformation_AppSettings_InputSensor_Audio:
    case RedvoxPacketM_StationInformation_AppSettings_InputSensor_CompressedAudio:
    case RedvoxPacketM_StationInformation_AppSettings_InputSensor_Gravity:
    case RedvoxPacketM_StationInformation_AppSettings_InputSensor_Gyroscope:
    case RedvoxPacketM_StationInformation_AppSettings_InputSensor_Image:
    case RedvoxPacketM_StationInformation_AppSettings_InputSensor_Light:
    case RedvoxPacketM_StationInformation_AppSettings_InputSensor_LinearAcceleration:
    case RedvoxPacketM_StationInformation_AppSettings_InputSensor_Location:
    case RedvoxPacketM_StationInformation_AppSettings_InputSensor_Magnetometer:
    case RedvoxPacketM_StationInformation_AppSettings_InputSensor_Orientation:
    case RedvoxPacketM_StationInformation_AppSettings_InputSensor_Pressure:
    case RedvoxPacketM_StationInformation_AppSettings_InputSensor_Proximity:
    case RedvoxPacketM_StationInformation_AppSettings_InputSensor_RelativeHumidity:
    case RedvoxPacketM_StationInformation_AppSettings_InputSensor_RotationVector:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RedvoxPacketM_TimingInformation

@implementation RedvoxPacketM_TimingInformation

@dynamic packetStartOsTimestamp;
@dynamic packetStartMachTimestamp;
@dynamic packetEndOsTimestamp;
@dynamic packetEndMachTimestamp;
@dynamic serverAcquisitionArrivalTimestamp;
@dynamic appStartMachTimestamp;
@dynamic synchExchangesArray, synchExchangesArray_Count;
@dynamic bestLatency;
@dynamic bestOffset;
@dynamic score;
@dynamic scoreMethod;
@dynamic unit;
@dynamic metadata, metadata_Count;

typedef struct RedvoxPacketM_TimingInformation__storage_ {
  uint32_t _has_storage_[1];
  float bestLatency;
  float bestOffset;
  float score;
  RedvoxPacketM_TimingInformation_TimingScoreMethod scoreMethod;
  RedvoxPacketM_Unit unit;
  NSMutableArray *synchExchangesArray;
  NSMutableDictionary *metadata;
  double packetStartOsTimestamp;
  double packetStartMachTimestamp;
  double packetEndOsTimestamp;
  double packetEndMachTimestamp;
  double serverAcquisitionArrivalTimestamp;
  double appStartMachTimestamp;
} RedvoxPacketM_TimingInformation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "packetStartOsTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_TimingInformation_FieldNumber_PacketStartOsTimestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingInformation__storage_, packetStartOsTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "packetStartMachTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_TimingInformation_FieldNumber_PacketStartMachTimestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingInformation__storage_, packetStartMachTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "packetEndOsTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_TimingInformation_FieldNumber_PacketEndOsTimestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingInformation__storage_, packetEndOsTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "packetEndMachTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_TimingInformation_FieldNumber_PacketEndMachTimestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingInformation__storage_, packetEndMachTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "serverAcquisitionArrivalTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_TimingInformation_FieldNumber_ServerAcquisitionArrivalTimestamp,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingInformation__storage_, serverAcquisitionArrivalTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "appStartMachTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_TimingInformation_FieldNumber_AppStartMachTimestamp,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingInformation__storage_, appStartMachTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "synchExchangesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_TimingInformation_SynchExchange),
        .number = RedvoxPacketM_TimingInformation_FieldNumber_SynchExchangesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingInformation__storage_, synchExchangesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bestLatency",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_TimingInformation_FieldNumber_BestLatency,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingInformation__storage_, bestLatency),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "bestOffset",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_TimingInformation_FieldNumber_BestOffset,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingInformation__storage_, bestOffset),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "score",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_TimingInformation_FieldNumber_Score,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingInformation__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "scoreMethod",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_TimingInformation_TimingScoreMethod_EnumDescriptor,
        .number = RedvoxPacketM_TimingInformation_FieldNumber_ScoreMethod,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingInformation__storage_, scoreMethod),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "unit",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_Unit_EnumDescriptor,
        .number = RedvoxPacketM_TimingInformation_FieldNumber_Unit,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingInformation__storage_, unit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_TimingInformation_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingInformation__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedvoxPacketM_TimingInformation class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedvoxPacketM_TimingInformation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RedvoxPacketM)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RedvoxPacketM_TimingInformation_ScoreMethod_RawValue(RedvoxPacketM_TimingInformation *message) {
  GPBDescriptor *descriptor = [RedvoxPacketM_TimingInformation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_TimingInformation_FieldNumber_ScoreMethod];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacketM_TimingInformation_ScoreMethod_RawValue(RedvoxPacketM_TimingInformation *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacketM_TimingInformation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_TimingInformation_FieldNumber_ScoreMethod];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t RedvoxPacketM_TimingInformation_Unit_RawValue(RedvoxPacketM_TimingInformation *message) {
  GPBDescriptor *descriptor = [RedvoxPacketM_TimingInformation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_TimingInformation_FieldNumber_Unit];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacketM_TimingInformation_Unit_RawValue(RedvoxPacketM_TimingInformation *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacketM_TimingInformation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_TimingInformation_FieldNumber_Unit];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RedvoxPacketM_TimingInformation_TimingScoreMethod

GPBEnumDescriptor *RedvoxPacketM_TimingInformation_TimingScoreMethod_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000";
    static const int32_t values[] = {
        RedvoxPacketM_TimingInformation_TimingScoreMethod_Unknown,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RedvoxPacketM_TimingInformation_TimingScoreMethod)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RedvoxPacketM_TimingInformation_TimingScoreMethod_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RedvoxPacketM_TimingInformation_TimingScoreMethod_IsValidValue(int32_t value__) {
  switch (value__) {
    case RedvoxPacketM_TimingInformation_TimingScoreMethod_Unknown:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RedvoxPacketM_TimingInformation_SynchExchange

@implementation RedvoxPacketM_TimingInformation_SynchExchange

@dynamic a1;
@dynamic a2;
@dynamic a3;
@dynamic b1;
@dynamic b2;
@dynamic b3;
@dynamic unit;
@dynamic metadata, metadata_Count;

typedef struct RedvoxPacketM_TimingInformation_SynchExchange__storage_ {
  uint32_t _has_storage_[1];
  RedvoxPacketM_Unit unit;
  NSMutableDictionary *metadata;
  double a1;
  double a2;
  double a3;
  double b1;
  double b2;
  double b3;
} RedvoxPacketM_TimingInformation_SynchExchange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "a1",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_TimingInformation_SynchExchange_FieldNumber_A1,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingInformation_SynchExchange__storage_, a1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "a2",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_TimingInformation_SynchExchange_FieldNumber_A2,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingInformation_SynchExchange__storage_, a2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "a3",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_TimingInformation_SynchExchange_FieldNumber_A3,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingInformation_SynchExchange__storage_, a3),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "b1",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_TimingInformation_SynchExchange_FieldNumber_B1,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingInformation_SynchExchange__storage_, b1),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "b2",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_TimingInformation_SynchExchange_FieldNumber_B2,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingInformation_SynchExchange__storage_, b2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "b3",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_TimingInformation_SynchExchange_FieldNumber_B3,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingInformation_SynchExchange__storage_, b3),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "unit",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_Unit_EnumDescriptor,
        .number = RedvoxPacketM_TimingInformation_SynchExchange_FieldNumber_Unit,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingInformation_SynchExchange__storage_, unit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_TimingInformation_SynchExchange_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingInformation_SynchExchange__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedvoxPacketM_TimingInformation_SynchExchange class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedvoxPacketM_TimingInformation_SynchExchange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RedvoxPacketM_TimingInformation)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RedvoxPacketM_TimingInformation_SynchExchange_Unit_RawValue(RedvoxPacketM_TimingInformation_SynchExchange *message) {
  GPBDescriptor *descriptor = [RedvoxPacketM_TimingInformation_SynchExchange descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_TimingInformation_SynchExchange_FieldNumber_Unit];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacketM_TimingInformation_SynchExchange_Unit_RawValue(RedvoxPacketM_TimingInformation_SynchExchange *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacketM_TimingInformation_SynchExchange descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_TimingInformation_SynchExchange_FieldNumber_Unit];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RedvoxPacketM_Sensors

@implementation RedvoxPacketM_Sensors

@dynamic hasAccelerometer, accelerometer;
@dynamic hasAmbientTemperature, ambientTemperature;
@dynamic hasAudio, audio;
@dynamic hasCompressedAudio, compressedAudio;
@dynamic hasGravity, gravity;
@dynamic hasGyroscope, gyroscope;
@dynamic hasImage, image;
@dynamic hasLight, light;
@dynamic hasLinearAcceleration, linearAcceleration;
@dynamic hasLocation, location;
@dynamic hasMagnetometer, magnetometer;
@dynamic hasOrientation, orientation;
@dynamic hasPressure, pressure;
@dynamic hasProximity, proximity;
@dynamic hasRelativeHumidity, relativeHumidity;
@dynamic hasRotationVector, rotationVector;
@dynamic metadata, metadata_Count;

typedef struct RedvoxPacketM_Sensors__storage_ {
  uint32_t _has_storage_[1];
  RedvoxPacketM_Sensors_Xyz *accelerometer;
  RedvoxPacketM_Sensors_Single *ambientTemperature;
  RedvoxPacketM_Sensors_Audio *audio;
  RedvoxPacketM_Sensors_CompressedAudio *compressedAudio;
  RedvoxPacketM_Sensors_Xyz *gravity;
  RedvoxPacketM_Sensors_Xyz *gyroscope;
  RedvoxPacketM_Sensors_Image *image;
  RedvoxPacketM_Sensors_Single *light;
  RedvoxPacketM_Sensors_Xyz *linearAcceleration;
  RedvoxPacketM_Sensors_Location *location;
  RedvoxPacketM_Sensors_Xyz *magnetometer;
  RedvoxPacketM_Sensors_Xyz *orientation;
  RedvoxPacketM_Sensors_Single *pressure;
  RedvoxPacketM_Sensors_Single *proximity;
  RedvoxPacketM_Sensors_Single *relativeHumidity;
  RedvoxPacketM_Sensors_Xyz *rotationVector;
  NSMutableDictionary *metadata;
} RedvoxPacketM_Sensors__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accelerometer",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_Sensors_Xyz),
        .number = RedvoxPacketM_Sensors_FieldNumber_Accelerometer,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors__storage_, accelerometer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ambientTemperature",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_Sensors_Single),
        .number = RedvoxPacketM_Sensors_FieldNumber_AmbientTemperature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors__storage_, ambientTemperature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "audio",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_Sensors_Audio),
        .number = RedvoxPacketM_Sensors_FieldNumber_Audio,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors__storage_, audio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "compressedAudio",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_Sensors_CompressedAudio),
        .number = RedvoxPacketM_Sensors_FieldNumber_CompressedAudio,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors__storage_, compressedAudio),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gravity",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_Sensors_Xyz),
        .number = RedvoxPacketM_Sensors_FieldNumber_Gravity,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors__storage_, gravity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "gyroscope",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_Sensors_Xyz),
        .number = RedvoxPacketM_Sensors_FieldNumber_Gyroscope,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors__storage_, gyroscope),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "image",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_Sensors_Image),
        .number = RedvoxPacketM_Sensors_FieldNumber_Image,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors__storage_, image),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "light",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_Sensors_Single),
        .number = RedvoxPacketM_Sensors_FieldNumber_Light,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors__storage_, light),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "linearAcceleration",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_Sensors_Xyz),
        .number = RedvoxPacketM_Sensors_FieldNumber_LinearAcceleration,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors__storage_, linearAcceleration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "location",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_Sensors_Location),
        .number = RedvoxPacketM_Sensors_FieldNumber_Location,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors__storage_, location),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "magnetometer",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_Sensors_Xyz),
        .number = RedvoxPacketM_Sensors_FieldNumber_Magnetometer,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors__storage_, magnetometer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "orientation",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_Sensors_Xyz),
        .number = RedvoxPacketM_Sensors_FieldNumber_Orientation,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors__storage_, orientation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pressure",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_Sensors_Single),
        .number = RedvoxPacketM_Sensors_FieldNumber_Pressure,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors__storage_, pressure),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "proximity",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_Sensors_Single),
        .number = RedvoxPacketM_Sensors_FieldNumber_Proximity,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors__storage_, proximity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "relativeHumidity",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_Sensors_Single),
        .number = RedvoxPacketM_Sensors_FieldNumber_RelativeHumidity,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors__storage_, relativeHumidity),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "rotationVector",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_Sensors_Xyz),
        .number = RedvoxPacketM_Sensors_FieldNumber_RotationVector,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors__storage_, rotationVector),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedvoxPacketM_Sensors class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedvoxPacketM_Sensors__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RedvoxPacketM)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RedvoxPacketM_Sensors_Audio

@implementation RedvoxPacketM_Sensors_Audio

@dynamic sensorDescription;
@dynamic firstSampleTimestamp;
@dynamic sampleRate;
@dynamic bitsOfPrecision;
@dynamic isScrambled;
@dynamic encoding;
@dynamic hasSamples, samples;
@dynamic metadata, metadata_Count;

typedef struct RedvoxPacketM_Sensors_Audio__storage_ {
  uint32_t _has_storage_[1];
  float sampleRate;
  float bitsOfPrecision;
  NSString *sensorDescription;
  NSString *encoding;
  RedvoxPacketM_SamplePayload *samples;
  NSMutableDictionary *metadata;
  double firstSampleTimestamp;
} RedvoxPacketM_Sensors_Audio__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sensorDescription",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Audio_FieldNumber_SensorDescription,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Audio__storage_, sensorDescription),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "firstSampleTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Audio_FieldNumber_FirstSampleTimestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Audio__storage_, firstSampleTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "sampleRate",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Audio_FieldNumber_SampleRate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Audio__storage_, sampleRate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "bitsOfPrecision",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Audio_FieldNumber_BitsOfPrecision,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Audio__storage_, bitsOfPrecision),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "isScrambled",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Audio_FieldNumber_IsScrambled,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "encoding",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Audio_FieldNumber_Encoding,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Audio__storage_, encoding),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "samples",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_SamplePayload),
        .number = RedvoxPacketM_Sensors_Audio_FieldNumber_Samples,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Audio__storage_, samples),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Audio_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Audio__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedvoxPacketM_Sensors_Audio class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedvoxPacketM_Sensors_Audio__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RedvoxPacketM_Sensors)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RedvoxPacketM_Sensors_CompressedAudio

@implementation RedvoxPacketM_Sensors_CompressedAudio

@dynamic sensorDescription;
@dynamic firstSampleTimestamp;
@dynamic sampleRate;
@dynamic isScrambled;
@dynamic audioBytes;
@dynamic audioCodec;
@dynamic metadata, metadata_Count;

typedef struct RedvoxPacketM_Sensors_CompressedAudio__storage_ {
  uint32_t _has_storage_[1];
  float sampleRate;
  RedvoxPacketM_Sensors_CompressedAudio_AudioCodec audioCodec;
  NSString *sensorDescription;
  NSData *audioBytes;
  NSMutableDictionary *metadata;
  double firstSampleTimestamp;
} RedvoxPacketM_Sensors_CompressedAudio__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sensorDescription",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_CompressedAudio_FieldNumber_SensorDescription,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_CompressedAudio__storage_, sensorDescription),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "firstSampleTimestamp",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_CompressedAudio_FieldNumber_FirstSampleTimestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_CompressedAudio__storage_, firstSampleTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "sampleRate",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_CompressedAudio_FieldNumber_SampleRate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_CompressedAudio__storage_, sampleRate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "isScrambled",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_CompressedAudio_FieldNumber_IsScrambled,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "audioBytes",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_CompressedAudio_FieldNumber_AudioBytes,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_CompressedAudio__storage_, audioBytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "audioCodec",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_Sensors_CompressedAudio_AudioCodec_EnumDescriptor,
        .number = RedvoxPacketM_Sensors_CompressedAudio_FieldNumber_AudioCodec,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_CompressedAudio__storage_, audioCodec),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_CompressedAudio_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_CompressedAudio__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedvoxPacketM_Sensors_CompressedAudio class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedvoxPacketM_Sensors_CompressedAudio__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RedvoxPacketM_Sensors)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RedvoxPacketM_Sensors_CompressedAudio_AudioCodec_RawValue(RedvoxPacketM_Sensors_CompressedAudio *message) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_CompressedAudio descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_CompressedAudio_FieldNumber_AudioCodec];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacketM_Sensors_CompressedAudio_AudioCodec_RawValue(RedvoxPacketM_Sensors_CompressedAudio *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_CompressedAudio descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_CompressedAudio_FieldNumber_AudioCodec];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RedvoxPacketM_Sensors_CompressedAudio_AudioCodec

GPBEnumDescriptor *RedvoxPacketM_Sensors_CompressedAudio_AudioCodec_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Flac\000";
    static const int32_t values[] = {
        RedvoxPacketM_Sensors_CompressedAudio_AudioCodec_Unknown,
        RedvoxPacketM_Sensors_CompressedAudio_AudioCodec_Flac,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RedvoxPacketM_Sensors_CompressedAudio_AudioCodec)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RedvoxPacketM_Sensors_CompressedAudio_AudioCodec_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RedvoxPacketM_Sensors_CompressedAudio_AudioCodec_IsValidValue(int32_t value__) {
  switch (value__) {
    case RedvoxPacketM_Sensors_CompressedAudio_AudioCodec_Unknown:
    case RedvoxPacketM_Sensors_CompressedAudio_AudioCodec_Flac:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RedvoxPacketM_Sensors_Single

@implementation RedvoxPacketM_Sensors_Single

@dynamic sensorDescription;
@dynamic hasTimestamps, timestamps;
@dynamic hasSamples, samples;
@dynamic metadata, metadata_Count;

typedef struct RedvoxPacketM_Sensors_Single__storage_ {
  uint32_t _has_storage_[1];
  NSString *sensorDescription;
  RedvoxPacketM_TimingPayload *timestamps;
  RedvoxPacketM_SamplePayload *samples;
  NSMutableDictionary *metadata;
} RedvoxPacketM_Sensors_Single__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sensorDescription",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Single_FieldNumber_SensorDescription,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Single__storage_, sensorDescription),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamps",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_TimingPayload),
        .number = RedvoxPacketM_Sensors_Single_FieldNumber_Timestamps,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Single__storage_, timestamps),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "samples",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_SamplePayload),
        .number = RedvoxPacketM_Sensors_Single_FieldNumber_Samples,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Single__storage_, samples),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Single_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Single__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedvoxPacketM_Sensors_Single class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedvoxPacketM_Sensors_Single__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RedvoxPacketM_Sensors)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RedvoxPacketM_Sensors_Location

@implementation RedvoxPacketM_Sensors_Location

@dynamic sensorDescription;
@dynamic hasTimestamps, timestamps;
@dynamic hasTimestampsGps, timestampsGps;
@dynamic hasLatitudeSamples, latitudeSamples;
@dynamic hasLongitudeSamples, longitudeSamples;
@dynamic hasAltitudeSamples, altitudeSamples;
@dynamic hasSpeedSamples, speedSamples;
@dynamic hasBearingSamples, bearingSamples;
@dynamic hasHorizontalAccuracySamples, horizontalAccuracySamples;
@dynamic hasVerticalAccuracySamples, verticalAccuracySamples;
@dynamic hasSpeedAccuracySamples, speedAccuracySamples;
@dynamic hasBearingAccuracySamples, bearingAccuracySamples;
@dynamic hasLastBestLocation, lastBestLocation;
@dynamic hasOverallBestLocation, overallBestLocation;
@dynamic locationPermissionsGranted;
@dynamic locationServicesRequested;
@dynamic locationServicesEnabled;
@dynamic locationProvidersArray, locationProvidersArray_Count;
@dynamic metadata, metadata_Count;

typedef struct RedvoxPacketM_Sensors_Location__storage_ {
  uint32_t _has_storage_[1];
  NSString *sensorDescription;
  RedvoxPacketM_TimingPayload *timestamps;
  RedvoxPacketM_TimingPayload *timestampsGps;
  RedvoxPacketM_DoubleSamplePayload *latitudeSamples;
  RedvoxPacketM_DoubleSamplePayload *longitudeSamples;
  RedvoxPacketM_SamplePayload *altitudeSamples;
  RedvoxPacketM_SamplePayload *speedSamples;
  RedvoxPacketM_SamplePayload *bearingSamples;
  RedvoxPacketM_SamplePayload *horizontalAccuracySamples;
  RedvoxPacketM_SamplePayload *verticalAccuracySamples;
  RedvoxPacketM_SamplePayload *speedAccuracySamples;
  RedvoxPacketM_SamplePayload *bearingAccuracySamples;
  RedvoxPacketM_Sensors_Location_BestLocation *lastBestLocation;
  RedvoxPacketM_Sensors_Location_BestLocation *overallBestLocation;
  GPBEnumArray *locationProvidersArray;
  NSMutableDictionary *metadata;
} RedvoxPacketM_Sensors_Location__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sensorDescription",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Location_FieldNumber_SensorDescription,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location__storage_, sensorDescription),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamps",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_TimingPayload),
        .number = RedvoxPacketM_Sensors_Location_FieldNumber_Timestamps,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location__storage_, timestamps),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "timestampsGps",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_TimingPayload),
        .number = RedvoxPacketM_Sensors_Location_FieldNumber_TimestampsGps,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location__storage_, timestampsGps),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "latitudeSamples",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_DoubleSamplePayload),
        .number = RedvoxPacketM_Sensors_Location_FieldNumber_LatitudeSamples,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location__storage_, latitudeSamples),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "longitudeSamples",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_DoubleSamplePayload),
        .number = RedvoxPacketM_Sensors_Location_FieldNumber_LongitudeSamples,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location__storage_, longitudeSamples),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "altitudeSamples",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_SamplePayload),
        .number = RedvoxPacketM_Sensors_Location_FieldNumber_AltitudeSamples,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location__storage_, altitudeSamples),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "speedSamples",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_SamplePayload),
        .number = RedvoxPacketM_Sensors_Location_FieldNumber_SpeedSamples,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location__storage_, speedSamples),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bearingSamples",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_SamplePayload),
        .number = RedvoxPacketM_Sensors_Location_FieldNumber_BearingSamples,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location__storage_, bearingSamples),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "horizontalAccuracySamples",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_SamplePayload),
        .number = RedvoxPacketM_Sensors_Location_FieldNumber_HorizontalAccuracySamples,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location__storage_, horizontalAccuracySamples),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "verticalAccuracySamples",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_SamplePayload),
        .number = RedvoxPacketM_Sensors_Location_FieldNumber_VerticalAccuracySamples,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location__storage_, verticalAccuracySamples),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "speedAccuracySamples",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_SamplePayload),
        .number = RedvoxPacketM_Sensors_Location_FieldNumber_SpeedAccuracySamples,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location__storage_, speedAccuracySamples),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bearingAccuracySamples",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_SamplePayload),
        .number = RedvoxPacketM_Sensors_Location_FieldNumber_BearingAccuracySamples,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location__storage_, bearingAccuracySamples),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "lastBestLocation",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_Sensors_Location_BestLocation),
        .number = RedvoxPacketM_Sensors_Location_FieldNumber_LastBestLocation,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location__storage_, lastBestLocation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "overallBestLocation",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_Sensors_Location_BestLocation),
        .number = RedvoxPacketM_Sensors_Location_FieldNumber_OverallBestLocation,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location__storage_, overallBestLocation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "locationPermissionsGranted",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Location_FieldNumber_LocationPermissionsGranted,
        .hasIndex = 14,
        .offset = 15,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "locationServicesRequested",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Location_FieldNumber_LocationServicesRequested,
        .hasIndex = 16,
        .offset = 17,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "locationServicesEnabled",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Location_FieldNumber_LocationServicesEnabled,
        .hasIndex = 18,
        .offset = 19,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "locationProvidersArray",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_Sensors_Location_LocationProvider_EnumDescriptor,
        .number = RedvoxPacketM_Sensors_Location_FieldNumber_LocationProvidersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location__storage_, locationProvidersArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Location_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedvoxPacketM_Sensors_Location class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedvoxPacketM_Sensors_Location__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RedvoxPacketM_Sensors)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum RedvoxPacketM_Sensors_Location_LocationProvider

GPBEnumDescriptor *RedvoxPacketM_Sensors_Location_LocationProvider_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000None\000User\000Gps\000Network\000";
    static const int32_t values[] = {
        RedvoxPacketM_Sensors_Location_LocationProvider_Unknown,
        RedvoxPacketM_Sensors_Location_LocationProvider_None,
        RedvoxPacketM_Sensors_Location_LocationProvider_User,
        RedvoxPacketM_Sensors_Location_LocationProvider_Gps,
        RedvoxPacketM_Sensors_Location_LocationProvider_Network,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RedvoxPacketM_Sensors_Location_LocationProvider)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RedvoxPacketM_Sensors_Location_LocationProvider_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RedvoxPacketM_Sensors_Location_LocationProvider_IsValidValue(int32_t value__) {
  switch (value__) {
    case RedvoxPacketM_Sensors_Location_LocationProvider_Unknown:
    case RedvoxPacketM_Sensors_Location_LocationProvider_None:
    case RedvoxPacketM_Sensors_Location_LocationProvider_User:
    case RedvoxPacketM_Sensors_Location_LocationProvider_Gps:
    case RedvoxPacketM_Sensors_Location_LocationProvider_Network:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RedvoxPacketM_Sensors_Location_BestLocation

@implementation RedvoxPacketM_Sensors_Location_BestLocation

@dynamic hasLatitudeLongitudeTimestamp, latitudeLongitudeTimestamp;
@dynamic hasAltitudeTimestamp, altitudeTimestamp;
@dynamic hasSpeedTimestamp, speedTimestamp;
@dynamic hasBearingTimestamp, bearingTimestamp;
@dynamic latitudeLongitudeUnit;
@dynamic altitudeUnit;
@dynamic speedUnit;
@dynamic bearingUnit;
@dynamic verticalAccuracyUnit;
@dynamic horizontalAccuracyUnit;
@dynamic speedAccuracyUnit;
@dynamic bearingAccuracyUnit;
@dynamic latitude;
@dynamic longitude;
@dynamic altitude;
@dynamic speed;
@dynamic bearing;
@dynamic verticalAccuracy;
@dynamic horizontalAccuracy;
@dynamic speedAccuracy;
@dynamic bearingAccuracy;
@dynamic score;
@dynamic method;
@dynamic locationProvider;
@dynamic metadata, metadata_Count;

typedef struct RedvoxPacketM_Sensors_Location_BestLocation__storage_ {
  uint32_t _has_storage_[1];
  RedvoxPacketM_Unit latitudeLongitudeUnit;
  RedvoxPacketM_Unit altitudeUnit;
  RedvoxPacketM_Unit speedUnit;
  RedvoxPacketM_Unit bearingUnit;
  RedvoxPacketM_Unit verticalAccuracyUnit;
  RedvoxPacketM_Unit horizontalAccuracyUnit;
  RedvoxPacketM_Unit speedAccuracyUnit;
  RedvoxPacketM_Unit bearingAccuracyUnit;
  float altitude;
  float speed;
  float bearing;
  float verticalAccuracy;
  float horizontalAccuracy;
  float speedAccuracy;
  float bearingAccuracy;
  float score;
  RedvoxPacketM_Sensors_Location_BestLocation_LocationScoreMethod method;
  RedvoxPacketM_Sensors_Location_LocationProvider locationProvider;
  RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp *latitudeLongitudeTimestamp;
  RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp *altitudeTimestamp;
  RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp *speedTimestamp;
  RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp *bearingTimestamp;
  NSMutableDictionary *metadata;
  double latitude;
  double longitude;
} RedvoxPacketM_Sensors_Location_BestLocation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latitudeLongitudeTimestamp",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp),
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_LatitudeLongitudeTimestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, latitudeLongitudeTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "altitudeTimestamp",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp),
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_AltitudeTimestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, altitudeTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "speedTimestamp",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp),
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_SpeedTimestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, speedTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "bearingTimestamp",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp),
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_BearingTimestamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, bearingTimestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "latitudeLongitudeUnit",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_Unit_EnumDescriptor,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_LatitudeLongitudeUnit,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, latitudeLongitudeUnit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "altitudeUnit",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_Unit_EnumDescriptor,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_AltitudeUnit,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, altitudeUnit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "speedUnit",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_Unit_EnumDescriptor,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_SpeedUnit,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, speedUnit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "bearingUnit",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_Unit_EnumDescriptor,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_BearingUnit,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, bearingUnit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "verticalAccuracyUnit",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_Unit_EnumDescriptor,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_VerticalAccuracyUnit,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, verticalAccuracyUnit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "horizontalAccuracyUnit",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_Unit_EnumDescriptor,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_HorizontalAccuracyUnit,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, horizontalAccuracyUnit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "speedAccuracyUnit",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_Unit_EnumDescriptor,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_SpeedAccuracyUnit,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, speedAccuracyUnit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "bearingAccuracyUnit",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_Unit_EnumDescriptor,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_BearingAccuracyUnit,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, bearingAccuracyUnit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "latitude",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_Latitude,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, latitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "longitude",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_Longitude,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, longitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "altitude",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_Altitude,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, altitude),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "speed",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_Speed,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, speed),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "bearing",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_Bearing,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, bearing),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "verticalAccuracy",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_VerticalAccuracy,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, verticalAccuracy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "horizontalAccuracy",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_HorizontalAccuracy,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, horizontalAccuracy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "speedAccuracy",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_SpeedAccuracy,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, speedAccuracy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "bearingAccuracy",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_BearingAccuracy,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, bearingAccuracy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "score",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_Score,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "method",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_Sensors_Location_BestLocation_LocationScoreMethod_EnumDescriptor,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_Method,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, method),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "locationProvider",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_Sensors_Location_LocationProvider_EnumDescriptor,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_LocationProvider,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, locationProvider),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedvoxPacketM_Sensors_Location_BestLocation class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedvoxPacketM_Sensors_Location_BestLocation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RedvoxPacketM_Sensors_Location)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RedvoxPacketM_Sensors_Location_BestLocation_LatitudeLongitudeUnit_RawValue(RedvoxPacketM_Sensors_Location_BestLocation *message) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Location_BestLocation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_LatitudeLongitudeUnit];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacketM_Sensors_Location_BestLocation_LatitudeLongitudeUnit_RawValue(RedvoxPacketM_Sensors_Location_BestLocation *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Location_BestLocation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_LatitudeLongitudeUnit];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t RedvoxPacketM_Sensors_Location_BestLocation_AltitudeUnit_RawValue(RedvoxPacketM_Sensors_Location_BestLocation *message) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Location_BestLocation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_AltitudeUnit];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacketM_Sensors_Location_BestLocation_AltitudeUnit_RawValue(RedvoxPacketM_Sensors_Location_BestLocation *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Location_BestLocation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_AltitudeUnit];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t RedvoxPacketM_Sensors_Location_BestLocation_SpeedUnit_RawValue(RedvoxPacketM_Sensors_Location_BestLocation *message) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Location_BestLocation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_SpeedUnit];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacketM_Sensors_Location_BestLocation_SpeedUnit_RawValue(RedvoxPacketM_Sensors_Location_BestLocation *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Location_BestLocation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_SpeedUnit];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t RedvoxPacketM_Sensors_Location_BestLocation_BearingUnit_RawValue(RedvoxPacketM_Sensors_Location_BestLocation *message) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Location_BestLocation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_BearingUnit];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacketM_Sensors_Location_BestLocation_BearingUnit_RawValue(RedvoxPacketM_Sensors_Location_BestLocation *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Location_BestLocation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_BearingUnit];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t RedvoxPacketM_Sensors_Location_BestLocation_VerticalAccuracyUnit_RawValue(RedvoxPacketM_Sensors_Location_BestLocation *message) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Location_BestLocation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_VerticalAccuracyUnit];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacketM_Sensors_Location_BestLocation_VerticalAccuracyUnit_RawValue(RedvoxPacketM_Sensors_Location_BestLocation *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Location_BestLocation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_VerticalAccuracyUnit];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t RedvoxPacketM_Sensors_Location_BestLocation_HorizontalAccuracyUnit_RawValue(RedvoxPacketM_Sensors_Location_BestLocation *message) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Location_BestLocation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_HorizontalAccuracyUnit];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacketM_Sensors_Location_BestLocation_HorizontalAccuracyUnit_RawValue(RedvoxPacketM_Sensors_Location_BestLocation *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Location_BestLocation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_HorizontalAccuracyUnit];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t RedvoxPacketM_Sensors_Location_BestLocation_SpeedAccuracyUnit_RawValue(RedvoxPacketM_Sensors_Location_BestLocation *message) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Location_BestLocation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_SpeedAccuracyUnit];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacketM_Sensors_Location_BestLocation_SpeedAccuracyUnit_RawValue(RedvoxPacketM_Sensors_Location_BestLocation *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Location_BestLocation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_SpeedAccuracyUnit];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t RedvoxPacketM_Sensors_Location_BestLocation_BearingAccuracyUnit_RawValue(RedvoxPacketM_Sensors_Location_BestLocation *message) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Location_BestLocation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_BearingAccuracyUnit];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacketM_Sensors_Location_BestLocation_BearingAccuracyUnit_RawValue(RedvoxPacketM_Sensors_Location_BestLocation *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Location_BestLocation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_BearingAccuracyUnit];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t RedvoxPacketM_Sensors_Location_BestLocation_Method_RawValue(RedvoxPacketM_Sensors_Location_BestLocation *message) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Location_BestLocation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_Method];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacketM_Sensors_Location_BestLocation_Method_RawValue(RedvoxPacketM_Sensors_Location_BestLocation *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Location_BestLocation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_Method];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t RedvoxPacketM_Sensors_Location_BestLocation_LocationProvider_RawValue(RedvoxPacketM_Sensors_Location_BestLocation *message) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Location_BestLocation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_LocationProvider];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacketM_Sensors_Location_BestLocation_LocationProvider_RawValue(RedvoxPacketM_Sensors_Location_BestLocation *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Location_BestLocation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Location_BestLocation_FieldNumber_LocationProvider];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RedvoxPacketM_Sensors_Location_BestLocation_LocationScoreMethod

GPBEnumDescriptor *RedvoxPacketM_Sensors_Location_BestLocation_LocationScoreMethod_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "UnknownMethod\000";
    static const int32_t values[] = {
        RedvoxPacketM_Sensors_Location_BestLocation_LocationScoreMethod_UnknownMethod,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RedvoxPacketM_Sensors_Location_BestLocation_LocationScoreMethod)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RedvoxPacketM_Sensors_Location_BestLocation_LocationScoreMethod_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RedvoxPacketM_Sensors_Location_BestLocation_LocationScoreMethod_IsValidValue(int32_t value__) {
  switch (value__) {
    case RedvoxPacketM_Sensors_Location_BestLocation_LocationScoreMethod_UnknownMethod:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp

@implementation RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp

@dynamic unit;
@dynamic mach;
@dynamic gps;
@dynamic metadata, metadata_Count;

typedef struct RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp__storage_ {
  uint32_t _has_storage_[1];
  RedvoxPacketM_Unit unit;
  NSMutableDictionary *metadata;
  double mach;
  double gps;
} RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "unit",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_Unit_EnumDescriptor,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp_FieldNumber_Unit,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp__storage_, unit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "mach",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp_FieldNumber_Mach,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp__storage_, mach),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "gps",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp_FieldNumber_Gps,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp__storage_, gps),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RedvoxPacketM_Sensors_Location_BestLocation)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp_Unit_RawValue(RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp *message) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp_FieldNumber_Unit];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp_Unit_RawValue(RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Location_BestLocation_BestTimestamp_FieldNumber_Unit];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RedvoxPacketM_Sensors_Xyz

@implementation RedvoxPacketM_Sensors_Xyz

@dynamic sensorDescription;
@dynamic hasTimestamps, timestamps;
@dynamic hasXSamples, xSamples;
@dynamic hasYSamples, ySamples;
@dynamic hasZSamples, zSamples;
@dynamic metadata, metadata_Count;

typedef struct RedvoxPacketM_Sensors_Xyz__storage_ {
  uint32_t _has_storage_[1];
  NSString *sensorDescription;
  RedvoxPacketM_TimingPayload *timestamps;
  RedvoxPacketM_SamplePayload *xSamples;
  RedvoxPacketM_SamplePayload *ySamples;
  RedvoxPacketM_SamplePayload *zSamples;
  NSMutableDictionary *metadata;
} RedvoxPacketM_Sensors_Xyz__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sensorDescription",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Xyz_FieldNumber_SensorDescription,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Xyz__storage_, sensorDescription),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamps",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_TimingPayload),
        .number = RedvoxPacketM_Sensors_Xyz_FieldNumber_Timestamps,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Xyz__storage_, timestamps),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "xSamples",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_SamplePayload),
        .number = RedvoxPacketM_Sensors_Xyz_FieldNumber_XSamples,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Xyz__storage_, xSamples),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "ySamples",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_SamplePayload),
        .number = RedvoxPacketM_Sensors_Xyz_FieldNumber_YSamples,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Xyz__storage_, ySamples),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "zSamples",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_SamplePayload),
        .number = RedvoxPacketM_Sensors_Xyz_FieldNumber_ZSamples,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Xyz__storage_, zSamples),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Xyz_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Xyz__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedvoxPacketM_Sensors_Xyz class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedvoxPacketM_Sensors_Xyz__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RedvoxPacketM_Sensors)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RedvoxPacketM_Sensors_Image

@implementation RedvoxPacketM_Sensors_Image

@dynamic sensorDescription;
@dynamic hasTimestamps, timestamps;
@dynamic samplesArray, samplesArray_Count;
@dynamic imageCodec;
@dynamic metadata, metadata_Count;

typedef struct RedvoxPacketM_Sensors_Image__storage_ {
  uint32_t _has_storage_[1];
  RedvoxPacketM_Sensors_Image_ImageCodec imageCodec;
  NSString *sensorDescription;
  RedvoxPacketM_TimingPayload *timestamps;
  NSMutableArray *samplesArray;
  NSMutableDictionary *metadata;
} RedvoxPacketM_Sensors_Image__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "sensorDescription",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Image_FieldNumber_SensorDescription,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Image__storage_, sensorDescription),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamps",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_TimingPayload),
        .number = RedvoxPacketM_Sensors_Image_FieldNumber_Timestamps,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Image__storage_, timestamps),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "samplesArray",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Image_FieldNumber_SamplesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Image__storage_, samplesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "imageCodec",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_Sensors_Image_ImageCodec_EnumDescriptor,
        .number = RedvoxPacketM_Sensors_Image_FieldNumber_ImageCodec,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Image__storage_, imageCodec),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_Sensors_Image_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_Sensors_Image__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedvoxPacketM_Sensors_Image class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedvoxPacketM_Sensors_Image__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RedvoxPacketM_Sensors)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RedvoxPacketM_Sensors_Image_ImageCodec_RawValue(RedvoxPacketM_Sensors_Image *message) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Image descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Image_FieldNumber_ImageCodec];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacketM_Sensors_Image_ImageCodec_RawValue(RedvoxPacketM_Sensors_Image *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacketM_Sensors_Image descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_Sensors_Image_FieldNumber_ImageCodec];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum RedvoxPacketM_Sensors_Image_ImageCodec

GPBEnumDescriptor *RedvoxPacketM_Sensors_Image_ImageCodec_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Png\000Jpg\000Bmp\000";
    static const int32_t values[] = {
        RedvoxPacketM_Sensors_Image_ImageCodec_Unknown,
        RedvoxPacketM_Sensors_Image_ImageCodec_Png,
        RedvoxPacketM_Sensors_Image_ImageCodec_Jpg,
        RedvoxPacketM_Sensors_Image_ImageCodec_Bmp,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RedvoxPacketM_Sensors_Image_ImageCodec)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RedvoxPacketM_Sensors_Image_ImageCodec_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RedvoxPacketM_Sensors_Image_ImageCodec_IsValidValue(int32_t value__) {
  switch (value__) {
    case RedvoxPacketM_Sensors_Image_ImageCodec_Unknown:
    case RedvoxPacketM_Sensors_Image_ImageCodec_Png:
    case RedvoxPacketM_Sensors_Image_ImageCodec_Jpg:
    case RedvoxPacketM_Sensors_Image_ImageCodec_Bmp:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RedvoxPacketM_EventStream

@implementation RedvoxPacketM_EventStream

@dynamic name;
@dynamic hasTimestamps, timestamps;
@dynamic eventsArray, eventsArray_Count;
@dynamic metadata, metadata_Count;

typedef struct RedvoxPacketM_EventStream__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  RedvoxPacketM_TimingPayload *timestamps;
  NSMutableArray *eventsArray;
  NSMutableDictionary *metadata;
} RedvoxPacketM_EventStream__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_EventStream_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedvoxPacketM_EventStream__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "timestamps",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_TimingPayload),
        .number = RedvoxPacketM_EventStream_FieldNumber_Timestamps,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedvoxPacketM_EventStream__storage_, timestamps),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "eventsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_EventStream_Event),
        .number = RedvoxPacketM_EventStream_FieldNumber_EventsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_EventStream__storage_, eventsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_EventStream_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_EventStream__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedvoxPacketM_EventStream class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedvoxPacketM_EventStream__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RedvoxPacketM)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RedvoxPacketM_EventStream_Event

@implementation RedvoxPacketM_EventStream_Event

@dynamic description_p;
@dynamic stringPayload, stringPayload_Count;
@dynamic numericPayload, numericPayload_Count;
@dynamic booleanPayload, booleanPayload_Count;
@dynamic bytePayload, bytePayload_Count;
@dynamic metadata, metadata_Count;

typedef struct RedvoxPacketM_EventStream_Event__storage_ {
  uint32_t _has_storage_[1];
  NSString *description_p;
  NSMutableDictionary *stringPayload;
  GPBStringDoubleDictionary *numericPayload;
  GPBStringBoolDictionary *booleanPayload;
  NSMutableDictionary *bytePayload;
  NSMutableDictionary *metadata;
} RedvoxPacketM_EventStream_Event__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "description_p",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_EventStream_Event_FieldNumber_Description_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedvoxPacketM_EventStream_Event__storage_, description_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stringPayload",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_EventStream_Event_FieldNumber_StringPayload,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_EventStream_Event__storage_, stringPayload),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "numericPayload",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_EventStream_Event_FieldNumber_NumericPayload,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_EventStream_Event__storage_, numericPayload),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "booleanPayload",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_EventStream_Event_FieldNumber_BooleanPayload,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_EventStream_Event__storage_, booleanPayload),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "bytePayload",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_EventStream_Event_FieldNumber_BytePayload,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_EventStream_Event__storage_, bytePayload),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_EventStream_Event_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_EventStream_Event__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedvoxPacketM_EventStream_Event class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedvoxPacketM_EventStream_Event__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RedvoxPacketM_EventStream)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RedvoxPacketM_SamplePayload

@implementation RedvoxPacketM_SamplePayload

@dynamic unit;
@dynamic valuesArray, valuesArray_Count;
@dynamic hasValueStatistics, valueStatistics;
@dynamic metadata, metadata_Count;

typedef struct RedvoxPacketM_SamplePayload__storage_ {
  uint32_t _has_storage_[1];
  RedvoxPacketM_Unit unit;
  GPBFloatArray *valuesArray;
  RedvoxPacketM_SummaryStatistics *valueStatistics;
  NSMutableDictionary *metadata;
} RedvoxPacketM_SamplePayload__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "unit",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_Unit_EnumDescriptor,
        .number = RedvoxPacketM_SamplePayload_FieldNumber_Unit,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedvoxPacketM_SamplePayload__storage_, unit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "valuesArray",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_SamplePayload_FieldNumber_ValuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_SamplePayload__storage_, valuesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "valueStatistics",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_SummaryStatistics),
        .number = RedvoxPacketM_SamplePayload_FieldNumber_ValueStatistics,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedvoxPacketM_SamplePayload__storage_, valueStatistics),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_SamplePayload_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_SamplePayload__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedvoxPacketM_SamplePayload class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedvoxPacketM_SamplePayload__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RedvoxPacketM)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RedvoxPacketM_SamplePayload_Unit_RawValue(RedvoxPacketM_SamplePayload *message) {
  GPBDescriptor *descriptor = [RedvoxPacketM_SamplePayload descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_SamplePayload_FieldNumber_Unit];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacketM_SamplePayload_Unit_RawValue(RedvoxPacketM_SamplePayload *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacketM_SamplePayload descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_SamplePayload_FieldNumber_Unit];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RedvoxPacketM_DoubleSamplePayload

@implementation RedvoxPacketM_DoubleSamplePayload

@dynamic unit;
@dynamic valuesArray, valuesArray_Count;
@dynamic hasValueStatistics, valueStatistics;
@dynamic metadata, metadata_Count;

typedef struct RedvoxPacketM_DoubleSamplePayload__storage_ {
  uint32_t _has_storage_[1];
  RedvoxPacketM_Unit unit;
  GPBDoubleArray *valuesArray;
  RedvoxPacketM_SummaryStatistics *valueStatistics;
  NSMutableDictionary *metadata;
} RedvoxPacketM_DoubleSamplePayload__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "unit",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_Unit_EnumDescriptor,
        .number = RedvoxPacketM_DoubleSamplePayload_FieldNumber_Unit,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedvoxPacketM_DoubleSamplePayload__storage_, unit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "valuesArray",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_DoubleSamplePayload_FieldNumber_ValuesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_DoubleSamplePayload__storage_, valuesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "valueStatistics",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_SummaryStatistics),
        .number = RedvoxPacketM_DoubleSamplePayload_FieldNumber_ValueStatistics,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedvoxPacketM_DoubleSamplePayload__storage_, valueStatistics),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_DoubleSamplePayload_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_DoubleSamplePayload__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedvoxPacketM_DoubleSamplePayload class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedvoxPacketM_DoubleSamplePayload__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RedvoxPacketM)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RedvoxPacketM_DoubleSamplePayload_Unit_RawValue(RedvoxPacketM_DoubleSamplePayload *message) {
  GPBDescriptor *descriptor = [RedvoxPacketM_DoubleSamplePayload descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_DoubleSamplePayload_FieldNumber_Unit];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacketM_DoubleSamplePayload_Unit_RawValue(RedvoxPacketM_DoubleSamplePayload *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacketM_DoubleSamplePayload descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_DoubleSamplePayload_FieldNumber_Unit];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RedvoxPacketM_TimingPayload

@implementation RedvoxPacketM_TimingPayload

@dynamic unit;
@dynamic timestampsArray, timestampsArray_Count;
@dynamic hasTimestampStatistics, timestampStatistics;
@dynamic meanSampleRate;
@dynamic stdevSampleRate;
@dynamic metadata, metadata_Count;

typedef struct RedvoxPacketM_TimingPayload__storage_ {
  uint32_t _has_storage_[1];
  RedvoxPacketM_Unit unit;
  float meanSampleRate;
  float stdevSampleRate;
  GPBDoubleArray *timestampsArray;
  RedvoxPacketM_SummaryStatistics *timestampStatistics;
  NSMutableDictionary *metadata;
} RedvoxPacketM_TimingPayload__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "unit",
        .dataTypeSpecific.enumDescFunc = RedvoxPacketM_Unit_EnumDescriptor,
        .number = RedvoxPacketM_TimingPayload_FieldNumber_Unit,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingPayload__storage_, unit),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "timestampsArray",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_TimingPayload_FieldNumber_TimestampsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingPayload__storage_, timestampsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "timestampStatistics",
        .dataTypeSpecific.className = GPBStringifySymbol(RedvoxPacketM_SummaryStatistics),
        .number = RedvoxPacketM_TimingPayload_FieldNumber_TimestampStatistics,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingPayload__storage_, timestampStatistics),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "meanSampleRate",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_TimingPayload_FieldNumber_MeanSampleRate,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingPayload__storage_, meanSampleRate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "stdevSampleRate",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_TimingPayload_FieldNumber_StdevSampleRate,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingPayload__storage_, stdevSampleRate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeFloat,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_TimingPayload_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_TimingPayload__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedvoxPacketM_TimingPayload class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedvoxPacketM_TimingPayload__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RedvoxPacketM)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RedvoxPacketM_TimingPayload_Unit_RawValue(RedvoxPacketM_TimingPayload *message) {
  GPBDescriptor *descriptor = [RedvoxPacketM_TimingPayload descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_TimingPayload_FieldNumber_Unit];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedvoxPacketM_TimingPayload_Unit_RawValue(RedvoxPacketM_TimingPayload *message, int32_t value) {
  GPBDescriptor *descriptor = [RedvoxPacketM_TimingPayload descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedvoxPacketM_TimingPayload_FieldNumber_Unit];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RedvoxPacketM_SummaryStatistics

@implementation RedvoxPacketM_SummaryStatistics

@dynamic count;
@dynamic mean;
@dynamic standardDeviation;
@dynamic min;
@dynamic max;
@dynamic range;
@dynamic metadata, metadata_Count;

typedef struct RedvoxPacketM_SummaryStatistics__storage_ {
  uint32_t _has_storage_[1];
  NSMutableDictionary *metadata;
  double count;
  double mean;
  double standardDeviation;
  double min;
  double max;
  double range;
} RedvoxPacketM_SummaryStatistics__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "count",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_SummaryStatistics_FieldNumber_Count,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedvoxPacketM_SummaryStatistics__storage_, count),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "mean",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_SummaryStatistics_FieldNumber_Mean,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedvoxPacketM_SummaryStatistics__storage_, mean),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "standardDeviation",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_SummaryStatistics_FieldNumber_StandardDeviation,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RedvoxPacketM_SummaryStatistics__storage_, standardDeviation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "min",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_SummaryStatistics_FieldNumber_Min,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RedvoxPacketM_SummaryStatistics__storage_, min),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "max",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_SummaryStatistics_FieldNumber_Max,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RedvoxPacketM_SummaryStatistics__storage_, max),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "range",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_SummaryStatistics_FieldNumber_Range,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RedvoxPacketM_SummaryStatistics__storage_, range),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "metadata",
        .dataTypeSpecific.className = NULL,
        .number = RedvoxPacketM_SummaryStatistics_FieldNumber_Metadata,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(RedvoxPacketM_SummaryStatistics__storage_, metadata),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedvoxPacketM_SummaryStatistics class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedvoxPacketM_SummaryStatistics__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RedvoxPacketM)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EncryptedRedvoxPacketM

@implementation EncryptedRedvoxPacketM

@dynamic header;
@dynamic packet;

typedef struct EncryptedRedvoxPacketM__storage_ {
  uint32_t _has_storage_[1];
  NSData *header;
  NSData *packet;
} EncryptedRedvoxPacketM__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "header",
        .dataTypeSpecific.className = NULL,
        .number = EncryptedRedvoxPacketM_FieldNumber_Header,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EncryptedRedvoxPacketM__storage_, header),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "packet",
        .dataTypeSpecific.className = NULL,
        .number = EncryptedRedvoxPacketM_FieldNumber_Packet,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EncryptedRedvoxPacketM__storage_, packet),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EncryptedRedvoxPacketM class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EncryptedRedvoxPacketM__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - EncryptedRedvoxPacketM_Header

@implementation EncryptedRedvoxPacketM_Header

@dynamic stationId;
@dynamic stationUuid;
@dynamic authToken;
@dynamic firebaseToken;
@dynamic authEmail;

typedef struct EncryptedRedvoxPacketM_Header__storage_ {
  uint32_t _has_storage_[1];
  NSString *stationId;
  NSString *stationUuid;
  NSString *authToken;
  NSString *firebaseToken;
  NSString *authEmail;
} EncryptedRedvoxPacketM_Header__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stationId",
        .dataTypeSpecific.className = NULL,
        .number = EncryptedRedvoxPacketM_Header_FieldNumber_StationId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EncryptedRedvoxPacketM_Header__storage_, stationId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stationUuid",
        .dataTypeSpecific.className = NULL,
        .number = EncryptedRedvoxPacketM_Header_FieldNumber_StationUuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(EncryptedRedvoxPacketM_Header__storage_, stationUuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "authToken",
        .dataTypeSpecific.className = NULL,
        .number = EncryptedRedvoxPacketM_Header_FieldNumber_AuthToken,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(EncryptedRedvoxPacketM_Header__storage_, authToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "firebaseToken",
        .dataTypeSpecific.className = NULL,
        .number = EncryptedRedvoxPacketM_Header_FieldNumber_FirebaseToken,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(EncryptedRedvoxPacketM_Header__storage_, firebaseToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "authEmail",
        .dataTypeSpecific.className = NULL,
        .number = EncryptedRedvoxPacketM_Header_FieldNumber_AuthEmail,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(EncryptedRedvoxPacketM_Header__storage_, authEmail),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EncryptedRedvoxPacketM_Header class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EncryptedRedvoxPacketM_Header__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(EncryptedRedvoxPacketM)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AcquisitionRequest

@implementation AcquisitionRequest

@dynamic authToken;
@dynamic firebaseToken;
@dynamic checksum;
@dynamic isEncrypted;
@dynamic payload;

typedef struct AcquisitionRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *authToken;
  NSString *firebaseToken;
  NSData *payload;
  int64_t checksum;
} AcquisitionRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "authToken",
        .dataTypeSpecific.className = NULL,
        .number = AcquisitionRequest_FieldNumber_AuthToken,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AcquisitionRequest__storage_, authToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "firebaseToken",
        .dataTypeSpecific.className = NULL,
        .number = AcquisitionRequest_FieldNumber_FirebaseToken,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AcquisitionRequest__storage_, firebaseToken),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "checksum",
        .dataTypeSpecific.className = NULL,
        .number = AcquisitionRequest_FieldNumber_Checksum,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AcquisitionRequest__storage_, checksum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isEncrypted",
        .dataTypeSpecific.className = NULL,
        .number = AcquisitionRequest_FieldNumber_IsEncrypted,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "payload",
        .dataTypeSpecific.className = NULL,
        .number = AcquisitionRequest_FieldNumber_Payload,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(AcquisitionRequest__storage_, payload),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AcquisitionRequest class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AcquisitionRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AcquisitionResponse

@implementation AcquisitionResponse

@dynamic responseType;
@dynamic checksum;
@dynamic details;
@dynamic resend;

typedef struct AcquisitionResponse__storage_ {
  uint32_t _has_storage_[1];
  AcquisitionResponse_ResponseType responseType;
  NSString *details;
  int64_t checksum;
} AcquisitionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "responseType",
        .dataTypeSpecific.enumDescFunc = AcquisitionResponse_ResponseType_EnumDescriptor,
        .number = AcquisitionResponse_FieldNumber_ResponseType,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AcquisitionResponse__storage_, responseType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "checksum",
        .dataTypeSpecific.className = NULL,
        .number = AcquisitionResponse_FieldNumber_Checksum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AcquisitionResponse__storage_, checksum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "details",
        .dataTypeSpecific.className = NULL,
        .number = AcquisitionResponse_FieldNumber_Details,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AcquisitionResponse__storage_, details),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "resend",
        .dataTypeSpecific.className = NULL,
        .number = AcquisitionResponse_FieldNumber_Resend,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AcquisitionResponse class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AcquisitionResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t AcquisitionResponse_ResponseType_RawValue(AcquisitionResponse *message) {
  GPBDescriptor *descriptor = [AcquisitionResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AcquisitionResponse_FieldNumber_ResponseType];
  return GPBGetMessageInt32Field(message, field);
}

void SetAcquisitionResponse_ResponseType_RawValue(AcquisitionResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [AcquisitionResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:AcquisitionResponse_FieldNumber_ResponseType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum AcquisitionResponse_ResponseType

GPBEnumDescriptor *AcquisitionResponse_ResponseType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Unknown\000Ok\000AuthError\000DataError\000OtherErro"
        "r\000";
    static const int32_t values[] = {
        AcquisitionResponse_ResponseType_Unknown,
        AcquisitionResponse_ResponseType_Ok,
        AcquisitionResponse_ResponseType_AuthError,
        AcquisitionResponse_ResponseType_DataError,
        AcquisitionResponse_ResponseType_OtherError,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AcquisitionResponse_ResponseType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AcquisitionResponse_ResponseType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AcquisitionResponse_ResponseType_IsValidValue(int32_t value__) {
  switch (value__) {
    case AcquisitionResponse_ResponseType_Unknown:
    case AcquisitionResponse_ResponseType_Ok:
    case AcquisitionResponse_ResponseType_AuthError:
    case AcquisitionResponse_ResponseType_DataError:
    case AcquisitionResponse_ResponseType_OtherError:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SynchRequest

@implementation SynchRequest

@dynamic stationId;
@dynamic stationUuid;
@dynamic seqId;
@dynamic subSeqId;

typedef struct SynchRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t seqId;
  uint32_t subSeqId;
  NSString *stationId;
  NSString *stationUuid;
} SynchRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stationId",
        .dataTypeSpecific.className = NULL,
        .number = SynchRequest_FieldNumber_StationId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SynchRequest__storage_, stationId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stationUuid",
        .dataTypeSpecific.className = NULL,
        .number = SynchRequest_FieldNumber_StationUuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SynchRequest__storage_, stationUuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "seqId",
        .dataTypeSpecific.className = NULL,
        .number = SynchRequest_FieldNumber_SeqId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SynchRequest__storage_, seqId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "subSeqId",
        .dataTypeSpecific.className = NULL,
        .number = SynchRequest_FieldNumber_SubSeqId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SynchRequest__storage_, subSeqId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SynchRequest class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SynchRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SynchResponse

@implementation SynchResponse

@dynamic stationId;
@dynamic stationUuid;
@dynamic seqId;
@dynamic subSeqId;
@dynamic recvTsUs;
@dynamic sendTsUs;

typedef struct SynchResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t seqId;
  uint32_t subSeqId;
  NSString *stationId;
  NSString *stationUuid;
  uint64_t recvTsUs;
  uint64_t sendTsUs;
} SynchResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "stationId",
        .dataTypeSpecific.className = NULL,
        .number = SynchResponse_FieldNumber_StationId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SynchResponse__storage_, stationId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "stationUuid",
        .dataTypeSpecific.className = NULL,
        .number = SynchResponse_FieldNumber_StationUuid,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SynchResponse__storage_, stationUuid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "seqId",
        .dataTypeSpecific.className = NULL,
        .number = SynchResponse_FieldNumber_SeqId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SynchResponse__storage_, seqId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "subSeqId",
        .dataTypeSpecific.className = NULL,
        .number = SynchResponse_FieldNumber_SubSeqId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(SynchResponse__storage_, subSeqId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "recvTsUs",
        .dataTypeSpecific.className = NULL,
        .number = SynchResponse_FieldNumber_RecvTsUs,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(SynchResponse__storage_, recvTsUs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "sendTsUs",
        .dataTypeSpecific.className = NULL,
        .number = SynchResponse_FieldNumber_SendTsUs,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(SynchResponse__storage_, sendTsUs),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SynchResponse class]
                                     rootClass:[RedvoxApiMRoot class]
                                          file:RedvoxApiMRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SynchResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
